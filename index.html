<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI-Assisted Novel Editor</title>
    <style>
      /* --- Existing styles --- */
      body {
        font-family: sans-serif;
        line-height: 1.6;
        margin: 20px;
        background-color: #f4f4f4;
        color: #333;
      }

      h1,
      h2,
      h3 {
        color: #333;
      }

      button {
        padding: 8px 12px;
        margin: 5px 2px;
        cursor: pointer;
        background-color: #5c67f2;
        color: white;
        border: none;
        border-radius: 4px;
      }

      button:hover {
        background-color: #4a54e1;
      }

      button.delete-btn {
        background-color: #e74c3c;
      }
      button.delete-btn:hover {
        background-color: #c0392b;
      }

      button.move-btn {
        background-color: #f39c12;
        font-weight: bold;
        padding: 4px 8px;
        min-width: 30px;
      }
      button.move-btn:hover {
        background-color: #e67e22;
      }
      button:disabled {
        background-color: #ccc;
        cursor: not-allowed;
      }

      button.secondary-btn {
        background-color: #7f8c8d;
      }
      button.secondary-btn:hover {
        background-color: #6c7a7b;
      }

      .container {
        max-width: 900px;
        margin: auto;
        background: white;
        padding: 20px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        border-radius: 8px;
      }

      #novelListView,
      #novelEditorView,
      #settingsView {
        margin-top: 20px;
      }

      #novelList {
        list-style: none;
        padding: 0;
      }

      #novelList li {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
        border-bottom: 1px solid #eee;
      }
      #novelList li:last-child {
        border-bottom: none;
      }

      .novel-item-title {
        font-weight: bold;
        cursor: pointer;
      }
      .novel-item-title:hover {
        color: #5c67f2;
      }

      .chapter {
        border: 1px solid #ccc;
        border-radius: 5px;
        padding: 15px;
        margin-bottom: 20px;
        background-color: #fff;
      }

      .chapter-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        flex-wrap: wrap; /* Allow wrapping on smaller screens */
      }

      .chapter-title {
        font-size: 1.2em;
        font-weight: bold;
        border: none;
        padding: 5px;
        flex-grow: 1; /* Allow title to take available space */
        margin-right: 10px; /* Space between title and buttons */
      }
      .chapter-title:focus {
        outline: 1px solid #5c67f2;
        background-color: #f0f0ff;
      }

      .chapter-controls button,
      .beat-controls button {
        margin-left: 5px;
      }

      .scene-beat {
        border: 1px dashed #ddd;
        padding: 10px;
        margin-top: 10px;
        background-color: #f9f9f9;
        border-radius: 4px;
      }

      textarea {
        width: 98%;
        min-height: 60px;
        margin-top: 5px;
        margin-bottom: 5px;
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-family: inherit;
        font-size: 1em;
        resize: vertical; /* Allow vertical resize */
        box-sizing: border-box; /* Include padding and border in the element's total width and height */
      }

      .beat-text-area {
        min-height: 40px;
      }

      .generated-text-area,
      .summary-text-area {
        min-height: 80px;
        background-color: #e8f0fe; /* Light blue background for generated content */
      }

      .beat-controls {
        display: flex;
        justify-content: flex-end;
        align-items: center;
        margin-top: 5px;
        flex-wrap: wrap;
      }

      .add-beat-area {
        margin-top: 15px;
        display: flex;
        align-items: center;
      }

      .add-beat-area textarea {
        flex-grow: 1;
        margin-right: 10px;
        min-height: 30px;
      }

      .feedback {
        color: green;
        font-size: 0.9em;
        margin-left: 10px;
        display: inline-block;
        opacity: 0;
        transition: opacity 0.5s ease-out;
      }
      .feedback.show {
        opacity: 1;
      }

      input[type="text"] {
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
      }

      .import-export-area {
        margin: 10px 0;
        padding: 10px;
        background: #f8f8f8;
        border-radius: 4px;
      }

      .import-area {
        display: none;
        margin-top: 10px;
      }

      .import-area.show {
        display: block;
      }

      .import-area textarea {
        width: 100%;
        min-height: 200px;
        margin: 10px 0;
        box-sizing: border-box; /* Added for consistency */
      }

      /* --- New styles for Settings --- */
      #settingsView {
        border: 1px solid #ddd;
        padding: 20px;
        background-color: #f9f9f9;
        border-radius: 5px;
      }
      #promptTemplateTextarea {
        width: 98%;
        min-height: 250px; /* Make it taller for template editing */
        font-family: monospace; /* Often better for template editing */
        font-size: 0.9em;
      }
      .template-help {
        font-size: 0.9em;
        color: #555;
        margin-bottom: 10px;
      }
      .template-help code {
        background-color: #eee;
        padding: 2px 4px;
        border-radius: 3px;
      }

      /* --- Modal Dialog Styles --- */
      .modal-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 1000;
        justify-content: center;
        align-items: center;
      }

      .modal-dialog {
        background-color: white;
        max-width: 80%;
        width: 800px;
        max-height: 80vh;
        border-radius: 8px;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
        display: flex;
        flex-direction: column;
      }

      .modal-header {
        padding: 15px;
        border-bottom: 1px solid #eee;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .modal-title {
        font-size: 1.2em;
        font-weight: bold;
        margin: 0;
      }

      .modal-close {
        background: none;
        border: none;
        font-size: 1.5em;
        cursor: pointer;
        color: #777;
        padding: 0;
        margin: 0;
      }

      .modal-body {
        padding: 15px;
        overflow-y: auto;
        flex-grow: 1;
      }

      .modal-footer {
        padding: 15px;
        border-top: 1px solid #eee;
        display: flex;
        justify-content: flex-end;
      }

      .prompt-textarea {
        width: 100%;
        min-height: 300px;
        font-family: monospace;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        margin-bottom: 10px;
        resize: vertical;
        box-sizing: border-box; /* Added for consistency */
      }

      /* --- New styles for collapsible summary --- */
      .summary-section {
        transition: max-height 0.3s ease-out;
        overflow: hidden;
      }

      .summary-section.collapsed {
        max-height: 0;
      }

      .summary-header {
        display: flex;
        align-items: center; /* Changed from start for better alignment */
        cursor: pointer;
        gap: 5px; /* Add some space between arrow and text */
      }

      .summary-header h4 {
        margin: 0;
      }

      .collapse-indicator {
        font-size: 18px; /* Adjust as needed */
        line-height: 1; /* Prevent extra space */
        transition: transform 0.3s;
        display: inline-block; /* Needed for transform */
      }

      .collapsed .collapse-indicator {
        transform: rotate(-90deg);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>AI-Assisted Novel Editor</h1>

      <!-- Novel List View -->
      <div id="novelListView">
        <h2>Novels</h2>
        <ul id="novelList">
          <!-- Novel list items will be injected here -->
        </ul>
        <div>
          <input type="text" id="newNovelTitle" placeholder="New Novel Title" />
          <button onclick="createNovel()">Create New Novel</button>
          <button onclick="toggleImportArea()">Import Novel</button>
        </div>
        <div class="import-area">
          <textarea
            id="importText"
            placeholder="Paste exported novel markdown here..."
          ></textarea>
          <button onclick="importNovel()">Import</button>
          <button class="secondary-btn" onclick="toggleImportArea()">Cancel</button>
        </div>
      </div>

      <!-- Old Settings View (Placeholder) - Can be removed if Template Editor Modal is sufficient -->
      <div id="settingsView" style="display: none">
        <h2>Settings</h2>
        <p>Settings content will go here. Use the 'Edit Templates' button in the editor view.</p>
        <button onclick="showNovelList()">← Back to Novel List</button>
      </div>

      <!-- Novel Editor View -->
      <div id="novelEditorView" style="display: none">
        <button onclick="showNovelList()">← Back to Novel List</button>
        <div class="novel-title-edit">
          <input
            type="text"
            id="editNovelTitle"
            oninput="updateNovelTitle(this.value)"
          />
        </div>
        <div class="import-export-area">
          <button onclick="exportNovel(this)">Export Novel</button>
          <button onclick="showTemplateEditor()">Edit Continue Prompt Template</button>
          <span class="feedback">Copied!</span>
        </div>
        <div class="chapter-filter">
          <label for="chapterFilter">Show chapter: </label>
          <select id="chapterFilter" onchange="filterChapters(this.value)">
            <option value="all">All Chapters</option>
            <!-- Chapter options will be injected here -->
          </select>
        </div>
        <button class="delete-btn" onclick="deleteCurrentNovel()">
          Delete This Novel
        </button>
        <hr />

        <div id="chaptersContainer">
          <!-- Chapters will be injected here -->
        </div>

        <button onclick="addChapter()">+ Add New Chapter</button>
      </div>

      <!-- Prompt Modal Dialog -->
      <div class="modal-overlay" id="promptModal">
        <div class="modal-dialog">
          <div class="modal-header">
            <h3 class="modal-title">Scene Beat Prompt</h3>
            <button class="modal-close" onclick="closePromptModal()">
              ×
            </button>
          </div>
          <div class="modal-body">
            <textarea
              id="promptTextarea"
              class="prompt-textarea"
              readonly
            ></textarea>
          </div>
          <div class="modal-footer">
            <button onclick="copyPromptFromModal()">Copy to Clipboard</button>
            <button class="secondary-btn" onclick="closePromptModal()">
              Close
            </button>
          </div>
        </div>
      </div>

      <!-- Template Editor Modal (dynamically created) -->

    </div>

    <script>
            const LS_KEY = "novels";
            const LS_TEMPLATE_KEY = "promptTemplate"; // Legacy key for default, now templates are stored per-novel
            let novels = [];
            let currentNovelId = null;

            // --- Default Prompt Template ---
            const DEFAULT_PROMPT_TEMPLATE = `The story so far:
{storySoFar}

You are an expert fiction writer. Continue the story and write about 400 words for the following instructions:
{instructions}

NEVER conclude the scene on your own, follow the beat instructions very closely. NEVER end with foreshadowing. NEVER write further than what I prompt you with. AVOID imagining possible endings, NEVER deviate from the instructions.

STOP EARLY if the continuation contains what was required in the instructions. You do not need to fill out the full amount of words possible.

- Do not use bold or italic font.
- Do not use expressions like "mechanical precision," "with rapid efficiency," or "at a steady pace", "her stride controlled, efficient", "this is not ideal".
- CT32F, from whose perspective the story is told, cannot feel or detect emotions in others. She cannot feel pain. She cannot assess things like beauty, nor does she feel the wind or cold.
- Do not measure parameters of the environment or mention these numbers.
- Write in active voice. Use British, American, Scientific, International, and Commercial English (Basic English) for everything except dialogues. For dialogues, use the language that ordinary people in the 1980x would use.
- Use sarcasm and dry humor. Make sarcastic jokes in the internal monologue.`;

            // --- Core Data Management ---

            function loadNovels() {
              const data = localStorage.getItem(LS_KEY);
              try {
                novels = data ? JSON.parse(data) : [];
              } catch (e) {
                console.error("Error loading novels from local storage:", e);
                novels = []; // Reset if data is corrupted
              }
              // Ensure basic structure integrity and add novel-specific template field if missing
              novels.forEach((novel) => {
                novel.template = novel.template || null; // Add template field if missing, default to null (will fallback to global)
                novel.chapters = novel.chapters || [];
                novel.chapters.forEach((chapter) => {
                  chapter.sceneBeats = chapter.sceneBeats || [];
                  chapter.summary = chapter.summary || "";
                  chapter.sceneBeats.forEach((beat) => {
                    beat.generatedText = beat.generatedText || "";
                  });
                });
              });
            }

            function saveNovels() {
              try {
                localStorage.setItem(LS_KEY, JSON.stringify(novels));
              } catch (e) {
                console.error("Error saving novels to local storage:", e);
                alert(
                  "Error saving data. Local storage might be full or unavailable."
                );
              }
            }

            function getNovelById(id) {
              return novels.find((novel) => novel.id === id);
            }

            function getChapterById(novel, chapterId) {
              return novel?.chapters.find((chap) => chap.id === chapterId);
            }

            function getSceneBeatById(chapter, beatId) {
              return chapter?.sceneBeats.find((beat) => beat.id === beatId);
            }

            function generateId() {
              return Date.now().toString(36) + Math.random().toString(36).substring(2);
            }

            // --- Prompt Template Management ---

            // Gets the novel-specific template or falls back to the default
            function getEffectiveTemplate(novel) {
                return novel?.template || DEFAULT_PROMPT_TEMPLATE;
            }

            // Used for the modal editor to show the correct content
            function showTemplateEditor() {
              const novel = getNovelById(currentNovelId);
              if (!novel) return;

              // Close existing modal if any
              const existingModal = document.querySelector('.modal-overlay[data-modal-type="template-editor"]');
              if (existingModal) existingModal.remove();

              const modal = document.createElement("div");
              modal.classList.add("modal-overlay");
              modal.dataset.modalType = "template-editor"; // Add identifier
              modal.style.display = "flex";
              modal.innerHTML = `
                <div class="modal-dialog">
                  <div class="modal-header">
                    <h3 class="modal-title">Edit Continue Prompt Template</h3>
                    <button class="modal-close" onclick="closeTemplateEditor(this)">×</button>
                  </div>
                  <div class="modal-body">
                    <textarea
                      id="templateTextarea"
                      class="prompt-textarea"
                    >${getEffectiveTemplate(novel)}</textarea> <!-- Use effective template -->
                    <div class="template-help">
                      <p>Use these placeholders:</p>
                      <ul>
                        <li><code>{storySoFar}</code> - Context from previous chapters/beats.</li>
                        <li><code>{instructions}</code> - The text from the current scene beat description.</li>
                      </ul>
                    </div>
                  </div>
                  <div class="modal-footer">
                    <button onclick="saveTemplate('${novel.id}', this)">Save Template</button>
                    <button class="secondary-btn" onclick="resetTemplateInEditor('${novel.id}')">Reset to Default</button>
                    <button class="secondary-btn" onclick="closeTemplateEditor(this)">Close</button>
                  </div>
                </div>
              `;
              document.body.appendChild(modal);
              // Focus the textarea
              const textarea = modal.querySelector('#templateTextarea');
              if (textarea) textarea.focus();
            }

            function closeTemplateEditor(button) {
              const modal = button.closest(".modal-overlay");
              if (modal) modal.remove();
            }

            function saveTemplate(novelId, button) {
              const novel = getNovelById(novelId);
              if (!novel) return;

              const textarea = document.getElementById("templateTextarea");
              if (textarea) {
                const newTemplate = textarea.value;
                // Only save if it's different from the default, otherwise store null
                novel.template = (newTemplate !== DEFAULT_PROMPT_TEMPLATE) ? newTemplate : null;
                saveNovels();
                // Show feedback within the modal
                const originalText = button.textContent;
                button.textContent = "Saved!";
                button.disabled = true;
                setTimeout(() => {
                   button.textContent = originalText;
                   button.disabled = false;
                }, 1500);
              }
            }

            function resetTemplateInEditor(novelId) {
                 if (confirm("Are you sure you want to reset the template in the editor to the default? This won't save until you click 'Save Template'.")) {
                    const textarea = document.getElementById("templateTextarea");
                    if (textarea) {
                        textarea.value = DEFAULT_PROMPT_TEMPLATE;
                    }
                }
            }

            // --- UI Rendering ---

            function renderNovelList() {
              const novelListEl = document.getElementById("novelList");
              novelListEl.innerHTML = ""; // Clear current list

              if (novels.length === 0) {
                novelListEl.innerHTML =
                  "<li>No novels found. Create one below or import one.</li>";
                return;
              }

              novels.sort((a, b) => (a.title || "").localeCompare(b.title || "")); // Sort novels alphabetically

              novels.forEach((novel) => {
                const li = document.createElement("li");
                li.innerHTML = `
                      <span class="novel-item-title" onclick="openNovel('${
                        novel.id
                      }')">${novel.title || "Untitled Novel"}</span>
                      <div>
                          <button onclick="openNovel('${novel.id}')">Open</button>
                          <button class="delete-btn" onclick="deleteNovel('${
                            novel.id
                          }')">Delete</button>
                      </div>
                  `;
                novelListEl.appendChild(li);
              });
            }

            function updateNovelTitle(newTitle) {
              const novel = getNovelById(currentNovelId);
              if (novel) {
                novel.title = newTitle.trim() || "Untitled Novel";
                saveNovels();
                 // No need to re-render entire list, just update title if needed (not strictly necessary)
              }
            }

            function renderNovelEditor() {
              const novel = getNovelById(currentNovelId);
              if (!novel) {
                console.error("Cannot render editor: Novel not found");
                showNovelList(); // Go back if novel doesn't exist
                return;
              }

              document.getElementById("editNovelTitle").value =
                novel.title || "Untitled Novel";
              const chaptersContainer = document.getElementById("chaptersContainer");
              chaptersContainer.innerHTML = ""; // Clear existing chapters

              const summaryStates = getChapterSummaryStates();

              novel.chapters.forEach((chapter, index) => {
                const chapterEl = document.createElement("div");
                chapterEl.classList.add("chapter");
                chapterEl.dataset.chapterId = chapter.id;
                chapterEl.dataset.chapterIndex = index; // Keep track of index for moving

                chapterEl.innerHTML = `
                      <div class="chapter-header">
                          <input
                              type="text"
                              class="chapter-title"
                              value="${chapter.title || "Untitled Chapter"}"
                              onchange="updateChapterTitle('${novel.id}', '${chapter.id}', this.value)"
                              placeholder="Chapter Title"
                          />
                          <div class="chapter-controls">
                              <button class="move-btn" onclick="moveChapter('${novel.id}', '${chapter.id}', -1)" ${
                  index === 0 ? "disabled" : ""
                }>↑</button>
                              <button class="move-btn" onclick="moveChapter('${novel.id}', '${chapter.id}', 1)" ${
                  index === novel.chapters.length - 1 ? "disabled" : ""
                }>↓</button>
                              <button class="delete-btn" onclick="deleteChapter('${novel.id}', '${chapter.id}')">Delete Chapter</button>
                          </div>
                      </div>

                      <div class="scene-beats-container">
                          <!-- Scene beats will be injected here -->
                      </div>

                      <div class="add-beat-area">
                          <textarea class="new-beat-text" placeholder="Add new scene beat instruction..."></textarea>
                          <button onclick="addSceneBeat('${novel.id}', '${chapter.id}')">+ Add Beat</button>
                      </div>

                      <hr style="margin: 15px 0;">

                      <div>
                          <div class="summary-header" onclick="toggleChapterSummary('${chapter.id}')">
                              <span class="collapse-indicator">▼</span> <!-- Default open arrow -->
                              <h4>Chapter Summary</h4>
                          </div>
                          <div class="summary-section" id="summary-section-${chapter.id}">
                              <button onclick="copyChapterSummaryPrompt('${novel.id}', '${chapter.id}', this)">Copy Summary Prompt</button>
                              <span class="feedback">Copied!</span>
                              <textarea
                                  class="summary-text-area"
                                  placeholder="Paste chapter summary generated by AI here..."
                                  onchange="updateChapterSummary('${novel.id}', '${chapter.id}', this.value)"
                              >${chapter.summary || ""}</textarea>
                          </div>
                      </div>
                  `;

                const summarySection = chapterEl.querySelector(
                  `#summary-section-${chapter.id}`
                );
                const indicator = chapterEl.querySelector(".collapse-indicator");
                // Default to collapsed (true) if no state is stored for this chapter
                const isCollapsed = summaryStates[chapter.id] ?? true; // Default collapsed

                if (summarySection && indicator) {
                  if (isCollapsed) {
                    summarySection.classList.add("collapsed");
                    indicator.style.transform = "rotate(-90deg)";
                  } else {
                    summarySection.classList.remove("collapsed");
                    indicator.style.transform = ""; // Default upright arrow
                  }
                }

                chaptersContainer.appendChild(chapterEl);
                renderSceneBeats(
                  novel.id,
                  chapter.id,
                  chapterEl.querySelector(".scene-beats-container")
                );
              });
              // Apply filter after rendering
              filterChapters(document.getElementById('chapterFilter').value);
            }

            function renderSceneBeats(novelId, chapterId, container) {
              const novel = getNovelById(novelId);
              const chapter = getChapterById(novel, chapterId);
              container.innerHTML = ""; // Clear existing beats

              if (!chapter || chapter.sceneBeats.length === 0) {
                container.innerHTML =
                  '<p style="color: #888; font-style: italic;">No scene beats yet.</p>';
                return;
              }

              chapter.sceneBeats.forEach((beat, index) => {
                const beatEl = document.createElement("div");
                beatEl.classList.add("scene-beat");
                beatEl.dataset.beatId = beat.id;
                beatEl.dataset.beatIndex = index; // Keep track of index for moving

                beatEl.innerHTML = `
                       <p style="margin-bottom: 2px; font-size: 0.9em; color: #555;"><strong>Scene Beat Instruction:</strong></p>
                      <textarea
                          class="beat-text-area"
                          placeholder="Scene beat description / instruction..."
                          onchange="updateSceneBeatText('${novelId}', '${chapterId}', '${beat.id}', this.value)"
                      >${beat.text || ""}</textarea>

                      <div class="beat-controls">
                          <button class="move-btn" onclick="moveSceneBeat('${novelId}', '${chapterId}', '${beat.id}', -1)" ${
                  index === 0 ? "disabled" : ""
                }>↑</button>
                          <button class="move-btn" onclick="moveSceneBeat('${novelId}', '${chapterId}', '${beat.id}', 1)" ${
                  index === chapter.sceneBeats.length - 1 ? "disabled" : ""
                }>↓</button>
                          <button onclick="showPromptDialog('${novelId}', '${chapterId}', '${beat.id}')">Show Prompt</button>
                          <button class="delete-btn" onclick="deleteSceneBeat('${novelId}', '${chapterId}', '${beat.id}')">Delete Beat</button>
                      </div>
                       <p style="margin-bottom: 2px; font-size: 0.9em; color: #555;"><strong>AI Generated Content:</strong></p>
                       <textarea
                          class="generated-text-area"
                          placeholder="Paste AI generated content here..."
                          onchange="updateGeneratedText('${novelId}', '${chapterId}', '${beat.id}', this.value)"
                      >${beat.generatedText || ""}</textarea>
                  `;
                container.appendChild(beatEl);
              });
            }

            // --- Render chapter filter dropdown ---
            function updateChapterFilter() {
              const novel = getNovelById(currentNovelId);
              const filterSelect = document.getElementById('chapterFilter');
              if (!novel || !filterSelect) return;

              // Save current selection if any
              const currentValue = filterSelect.value;

              // Clear existing options except for "All Chapters"
              while (filterSelect.options.length > 1) {
                filterSelect.remove(1);
              }

              // Add option for each chapter
              novel.chapters.forEach((chapter, index) => {
                const option = document.createElement('option');
                option.value = chapter.id;
                option.textContent = chapter.title || `Chapter ${index + 1}`;
                filterSelect.appendChild(option);
              });

              // Restore selection if possible, otherwise default to 'all'
              if (currentValue && novel.chapters.some(ch => ch.id === currentValue)) {
                 filterSelect.value = currentValue;
              } else {
                 filterSelect.value = 'all'; // Default to All Chapters
              }

              // Apply the filter (important after loading/modifying chapters)
              filterChapters(filterSelect.value);
            }

            // --- Filter chapters based on selection ---
            function filterChapters(chapterId) {
              const chaptersContainer = document.getElementById('chaptersContainer');
              if (!chaptersContainer) return;
              const chapterElements = chaptersContainer.querySelectorAll('.chapter');

              let foundVisible = false;
              chapterElements.forEach(el => {
                const isVisible = (chapterId === 'all' || el.dataset.chapterId === chapterId);
                el.style.display = isVisible ? 'block' : 'none';
                if (isVisible) foundVisible = true;
              });

              // Optional: Add message if filter results in no visible chapters
               if (chapterId !== 'all' && !foundVisible && chapterElements.length > 0) {
                   let messageEl = chaptersContainer.querySelector('.no-chapter-match-message');
                   if (!messageEl) {
                       messageEl = document.createElement('p');
                       messageEl.className = 'no-chapter-match-message';
                       messageEl.style.fontStyle = 'italic';
                       messageEl.style.color = '#888';
                       chaptersContainer.appendChild(messageEl);
                   }
                   messageEl.textContent = `Chapter not found or no chapters exist matching the filter. Showing all.`;
                   filterSelect.value = 'all'; // Reset dropdown
                   filterChapters('all'); // Show all again
               } else {
                   const messageEl = chaptersContainer.querySelector('.no-chapter-match-message');
                   if (messageEl) messageEl.remove(); // Remove message if chapters are visible
               }
            }

            // --- UI Navigation ---

            function showView(viewId) {
              document.getElementById("novelListView").style.display = "none";
              document.getElementById("novelEditorView").style.display = "none";
              document.getElementById("settingsView").style.display = "none"; // Hide placeholder settings view

              const view = document.getElementById(viewId);
              if (view) {
                view.style.display = "block";
              } else {
                console.error("Attempted to show unknown view:", viewId);
                document.getElementById("novelListView").style.display = "block"; // Fallback
              }
            }

            function showNovelList() {
              currentNovelId = null;
              showView("novelListView");
              document.getElementById("newNovelTitle").value = ""; // Clear input field
              const importArea = document.querySelector(".import-area");
              importArea.classList.remove("show"); // Hide import area if open
              document.getElementById("importText").value = "";
              renderNovelList();
            }

            function showNovelEditor() {
              if (!currentNovelId) return;
              showView("novelEditorView");
              renderNovelEditor();
              updateChapterFilter(); // Update and apply the chapter filter dropdown
            }

            // --- Novel Actions ---

            function createNovel() {
              const titleInput = document.getElementById("newNovelTitle");
              const title = titleInput.value.trim() || "Untitled Novel";
              const newNovel = {
                id: generateId(),
                title: title,
                template: null, // Initialize template as null (will use default)
                chapters: [],
              };
              novels.push(newNovel);
              saveNovels();
              titleInput.value = ""; // Clear input
              openNovel(newNovel.id); // Automatically open the new novel
            }

            function openNovel(id) {
              currentNovelId = id;
              showNovelEditor();
            }

            function deleteNovel(id) {
              const novelToDelete = getNovelById(id);
              if (!novelToDelete) return;
              if (
                confirm(
                  `Are you sure you want to delete the novel "${
                    novelToDelete.title || "Untitled Novel"
                  }"? This action cannot be undone.`
                )
              ) {
                novels = novels.filter((novel) => novel.id !== id);
                saveNovels();
                renderNovelList(); // Refresh list view
              }
            }

            function deleteCurrentNovel() {
              if (currentNovelId) {
                const novelToDelete = getNovelById(currentNovelId);
                if (!novelToDelete) return;
                if (
                  confirm(
                    `Are you sure you want to delete the novel "${
                      novelToDelete.title || "Untitled Novel"
                    }"? This action cannot be undone.`
                  )
                ) {
                  novels = novels.filter((novel) => novel.id !== currentNovelId);
                  saveNovels();
                  showNovelList(); // Go back to list view
                }
              }
            }

            // --- Chapter Actions ---

            function addChapter() {
              const novel = getNovelById(currentNovelId);
              if (!novel) return;

              const newChapter = {
                id: generateId(),
                title: `Chapter ${novel.chapters.length + 1}`,
                sceneBeats: [],
                summary: "",
              };
              novel.chapters.push(newChapter);
              saveNovels();
              renderNovelEditor();
              updateChapterFilter(); // Update filter after adding a chapter
              // Scroll to the new chapter? Optional.
               setTimeout(() => { // Allow DOM update
                   const newChapterEl = document.querySelector(`.chapter[data-chapter-id="${newChapter.id}"]`);
                   if(newChapterEl) newChapterEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
               }, 100);
            }

            function deleteChapter(novelId, chapterId) {
              const novel = getNovelById(novelId);
              if (!novel) return;
              const chapterIndex = novel.chapters.findIndex(ch => ch.id === chapterId);
              if (chapterIndex === -1) return; // Not found

              const chapter = novel.chapters[chapterIndex];

              if (
                confirm(
                  `Are you sure you want to delete "${
                    chapter?.title || "this chapter"
                  }" and all its scene beats?`
                )
              ) {
                novel.chapters.splice(chapterIndex, 1); // Remove chapter by index
                removeChapterSummaryState(chapterId); // Clean up summary state
                saveNovels();
                renderNovelEditor(); // Re-render the editor view
                updateChapterFilter(); // Update filter after deleting
              }
            }

            function updateChapterTitle(novelId, chapterId, newTitle) {
              const novel = getNovelById(novelId);
              const chapter = getChapterById(novel, chapterId);
              if (chapter) {
                chapter.title = newTitle.trim() || "Untitled Chapter";
                saveNovels();
                updateChapterFilter(); // Update filter when title changes
              }
            }

            // Updated moveChapter to use chapter ID for robustness
            function moveChapter(novelId, chapterId, direction) {
              // direction: -1 for up, 1 for down
              const novel = getNovelById(novelId);
              if (!novel) return;

              const chapterIndex = novel.chapters.findIndex(ch => ch.id === chapterId);
              if (chapterIndex === -1) return; // Chapter not found

              const newIndex = chapterIndex + direction;
              if (newIndex < 0 || newIndex >= novel.chapters.length) {
                return; // Invalid move
              }

              // Swap elements
              const temp = novel.chapters[chapterIndex];
              novel.chapters[chapterIndex] = novel.chapters[newIndex];
              novel.chapters[newIndex] = temp;
              // Or using array destructuring:
              // [novel.chapters[chapterIndex], novel.chapters[newIndex]] = [novel.chapters[newIndex], novel.chapters[chapterIndex]];

              saveNovels();
              const currentFilter = document.getElementById('chapterFilter').value; // Preserve filter
              renderNovelEditor(); // Re-render to reflect new order
              updateChapterFilter(); // Update filter dropdown order
              document.getElementById('chapterFilter').value = currentFilter; // Restore filter selection
              filterChapters(currentFilter); // Re-apply filter
            }

            // --- Scene Beat Actions ---

            function addSceneBeat(novelId, chapterId) {
              const novel = getNovelById(novelId);
              const chapter = getChapterById(novel, chapterId);
              if (!chapter) return;

              // Find the specific chapter element to get the text from the correct input
              const chapterElement = document.querySelector(
                `.chapter[data-chapter-id="${chapterId}"]`
              );
              if (!chapterElement) return;
              const newBeatTextArea = chapterElement.querySelector(".new-beat-text");
              const text = newBeatTextArea.value.trim();

              if (!text) {
                alert("Please enter some text for the scene beat instruction.");
                return;
              }

              const newBeat = {
                id: generateId(),
                text: text,
                generatedText: "",
              };
              chapter.sceneBeats.push(newBeat);
              saveNovels();
              newBeatTextArea.value = ""; // Clear the input field

              // Re-render just the scene beats for this chapter for efficiency
              const beatsContainer = chapterElement.querySelector(
                ".scene-beats-container"
              );
              renderSceneBeats(novelId, chapterId, beatsContainer);
              newBeatTextArea.focus(); // Focus input for quick next entry

              // Ensure summaries are properly initialized (might not be needed here, but safe)
              // initializeCollapsibleSummaries(); // Called within renderNovelEditor -> renderSceneBeats lifecycle
            }

            function deleteSceneBeat(novelId, chapterId, beatId) {
              const novel = getNovelById(novelId);
              const chapter = getChapterById(novel, chapterId);
              if (!chapter) return;

              const beatIndex = chapter.sceneBeats.findIndex(b => b.id === beatId);
              if (beatIndex === -1) return; // Not found

              if (confirm("Are you sure you want to delete this scene beat?")) {
                chapter.sceneBeats.splice(beatIndex, 1); // Remove beat by index
                saveNovels();
                // Re-render just the scene beats for this chapter
                const chapterElement = document.querySelector(
                  `.chapter[data-chapter-id="${chapterId}"]`
                );
                if (chapterElement) {
                  const beatsContainer = chapterElement.querySelector(
                    ".scene-beats-container"
                  );
                  renderSceneBeats(novelId, chapterId, beatsContainer);
                } else {
                  renderNovelEditor(); // Fallback to full render if element not found
                }
              }
            }

            function updateSceneBeatText(novelId, chapterId, beatId, newText) {
              const novel = getNovelById(novelId);
              const chapter = getChapterById(novel, chapterId);
              const beat = getSceneBeatById(chapter, beatId);
              // No trimming here, preserve user input exactly
              if (beat && beat.text !== newText) {
                beat.text = newText;
                saveNovels();
              }
            }

            function updateGeneratedText(novelId, chapterId, beatId, genText) {
              const novel = getNovelById(novelId);
              const chapter = getChapterById(novel, chapterId);
              const beat = getSceneBeatById(chapter, beatId);
              // No trimming here, preserve AI output exactly
              if (beat && beat.generatedText !== genText) {
                beat.generatedText = genText;
                saveNovels();
              }
            }

             // Updated moveSceneBeat to use beat ID for robustness
            function moveSceneBeat(novelId, chapterId, beatId, direction) {
              // -1 up, 1 down
              const novel = getNovelById(novelId);
              const chapter = getChapterById(novel, chapterId);
              if (!chapter) return;

              const beatIndex = chapter.sceneBeats.findIndex(b => b.id === beatId);
               if (beatIndex === -1) return; // Beat not found

              const newIndex = beatIndex + direction;
              if (newIndex < 0 || newIndex >= chapter.sceneBeats.length) {
                return; // Invalid move
              }

              // Swap elements
               const temp = chapter.sceneBeats[beatIndex];
               chapter.sceneBeats[beatIndex] = chapter.sceneBeats[newIndex];
               chapter.sceneBeats[newIndex] = temp;
              // Or using array destructuring:
              // [chapter.sceneBeats[beatIndex], chapter.sceneBeats[newIndex]] = [chapter.sceneBeats[newIndex], chapter.sceneBeats[beatIndex]];

              saveNovels();
              // Re-render just the scene beats for this chapter
              const chapterElement = document.querySelector(
                `.chapter[data-chapter-id="${chapterId}"]`
              );
              if (chapterElement) {
                const beatsContainer = chapterElement.querySelector(
                  ".scene-beats-container"
                );
                renderSceneBeats(novelId, chapterId, beatsContainer);
              } else {
                renderNovelEditor(); // Fallback to full render
              }
            }

            function updateChapterSummary(novelId, chapterId, summaryText) {
                const novel = getNovelById(novelId);
                const chapter = getChapterById(novel, chapterId);
                if (chapter && chapter.summary !== summaryText) {
                    chapter.summary = summaryText; // Preserve exact text
                    saveNovels();
                }
            }

            // --- Prompt Generation & Clipboard ---

            function showPromptDialog(novelId, chapterId, beatId) {
              const novel = getNovelById(novelId);
              const chapter = getChapterById(novel, chapterId);
              const beat = getSceneBeatById(chapter, beatId);
              if (!novel || !chapter || !beat) {
                  console.error("Missing data for prompt generation:", { novelId, chapterId, beatId });
                  alert("Error: Could not find necessary data to generate prompt.");
                  return;
              }

              // Find indices
              const chapterIndex = novel.chapters.findIndex(ch => ch.id === chapterId);
              const beatIndex = chapter.sceneBeats.findIndex(b => b.id === beatId);
              if (chapterIndex === -1 || beatIndex === -1) {
                   console.error("Error finding chapter/beat index:", { chapterIndex, beatIndex });
                   alert("Error: Could not determine position in story.");
                   return;
              }

              // Build story so far section
              let storySoFar = "";
              const maxContextLength = 10000; // Limit context length (characters) to avoid overly long prompts

              // 1. Add previous chapters' summaries (or full text if no summary)
              for (let i = 0; i < chapterIndex; i++) {
                const prevChapter = novel.chapters[i];
                let chapterContext = "";
                if (prevChapter.summary) {
                  chapterContext = `Summary of Chapter ${i + 1}: ${prevChapter.title || "Untitled"}\n${prevChapter.summary}\n\n`;
                } else {
                  // Fallback: Use generated text of previous chapter beats if no summary
                  const prevChapterText = prevChapter.sceneBeats
                    .map((b) => b.generatedText || "") // Prioritize generated text
                    .filter(Boolean) // Remove empty strings
                    .join("\n\n"); // Separate beats clearly
                  if (prevChapterText) {
                     chapterContext = `Content from Chapter ${i + 1}: ${prevChapter.title || "Untitled"}\n${prevChapterText}\n\n`;
                  }
                }
                 // Add context if it doesn't exceed limit drastically (rough check)
                 if ((storySoFar.length + chapterContext.length) < maxContextLength * 1.2) {
                    storySoFar += chapterContext;
                 } else {
                    console.warn(`Context limit reached, stopping at Chapter ${i}`);
                    break; // Stop adding chapters if context gets too long
                 }
              }

              // 2. Add current chapter's previous generated beats' text
              for (let i = 0; i < beatIndex; i++) {
                const prevBeat = chapter.sceneBeats[i];
                if (prevBeat.generatedText) {
                   const beatText = prevBeat.generatedText + "\n\n"; // Double newline between beats
                   if ((storySoFar.length + beatText.length) < maxContextLength * 1.2) {
                       storySoFar += beatText;
                   } else {
                       console.warn(`Context limit reached, stopping at Beat ${i} in Chapter ${chapterIndex + 1}`);
                       break; // Stop adding beats if context gets too long
                   }
                }
              }

              // Truncate storySoFar if it exceeds the limit
              if (storySoFar.length > maxContextLength) {
                 const excess = storySoFar.length - maxContextLength;
                 storySoFar = `... (trimmed ${excess} characters)\n` + storySoFar.slice(excess);
                 console.warn(`Story context truncated to ${maxContextLength} characters.`);
              }

              storySoFar = storySoFar.trim();

              // Get the effective template for this novel
              const template = getEffectiveTemplate(novel);

              // Prepare the instructions (current beat's text)
              const instructionsText = beat.text || "";

              // Replace placeholders
              let prompt = template.replace(
                "{storySoFar}",
                storySoFar || "This is the beginning of the story." // Add fallback if storySoFar is empty
              );
              prompt = prompt.replace("{instructions}", instructionsText);

              // Show the prompt in the modal
              document.getElementById("promptTextarea").value = prompt.trim();

              // Display the modal
              const modal = document.getElementById("promptModal");
              modal.style.display = "flex";
            }

            function closePromptModal() {
              const modal = document.getElementById("promptModal");
              modal.style.display = "none";
            }

            function copyPromptFromModal() {
              const promptText = document.getElementById("promptTextarea").value;
              const copyButton = document.querySelector("#promptModal .modal-footer button:first-child"); // More specific selector
              copyToClipboard(promptText, copyButton); // Reuse copyToClipboard
            }

            function showFeedback(buttonElement, message = "Copied!") {
              // Show feedback next to the button or find a suitable sibling
              let feedbackEl = buttonElement?.nextElementSibling;
              if (!feedbackEl || !feedbackEl.classList.contains("feedback")) {
                  // If no direct sibling, maybe it's inside a parent div
                  feedbackEl = buttonElement?.closest('div')?.querySelector('.feedback');
              }

              // Handle feedback for modal buttons specifically
               if (buttonElement?.closest('.modal-footer')) {
                  const originalText = buttonElement.textContent;
                  buttonElement.textContent = message;
                  buttonElement.disabled = true;
                  setTimeout(() => {
                      buttonElement.textContent = originalText;
                      buttonElement.disabled = false;
                  }, 1500);
                  return; // Don't use the .feedback span for modal buttons
               }

              if (feedbackEl) {
                feedbackEl.textContent = message; // Allow custom messages
                feedbackEl.classList.add("show");
                setTimeout(() => {
                  feedbackEl.classList.remove("show");
                   feedbackEl.textContent = "Copied!"; // Reset text
                }, 1500); // Hide after 1.5 seconds
              } else {
                console.warn("Could not find feedback element for button:", buttonElement);
                // Fallback alert if feedback element isn't found
                // alert(message);
              }
            }

            function copyToClipboard(text, buttonElement) {
              if (!text) {
                  console.warn("Attempted to copy empty text.");
                  showFeedback(buttonElement, "Nothing to copy!");
                  return;
              }
              navigator.clipboard
                .writeText(text)
                .then(() => {
                  showFeedback(buttonElement); // Default "Copied!" message
                  console.log("Text copied to clipboard");
                })
                .catch((err) => {
                  console.error("Failed to copy text: ", err);
                  alert(
                    "Failed to copy text. Your browser might not support this feature or permission was denied."
                  );
                });
            }

            function copyChapterSummaryPrompt(novelId, chapterId, buttonElement) {
              const novel = getNovelById(novelId);
              const chapter = getChapterById(novel, chapterId);
              if (!chapter) return;

              // Collect only the generated text for summary.
              let chapterText = chapter.sceneBeats
                .map((beat) => beat.generatedText || "") // Only generated text
                .filter(Boolean) // Filter out empty strings
                .join("\n\n"); // Join with double newline for clarity

              if (!chapterText) {
                  alert("No generated content in this chapter to summarize.");
                  return;
              }

              const prompt = `Please write a concise summary of the following chapter content:\n\n${chapterText}`;
              copyToClipboard(prompt, buttonElement);
            }

            // copyContinuePrompt is effectively replaced by showPromptDialog + copyPromptFromModal
            // Kept here for reference or potential future use if direct button is needed again.
            // function copyContinuePrompt(novelId, chapterId, beatId, buttonElement) {
            //    showPromptDialog(novelId, chapterId, beatId); // Generates the prompt
            //    const promptText = document.getElementById("promptTextarea").value; // Gets generated prompt
            //    copyToClipboard(promptText, buttonElement); // Copies it
            //    closePromptModal(); // Optionally close modal after copy
            // }


            // --- Import / Export ---

            function exportNovel(buttonElement) {
              const novel = getNovelById(currentNovelId);
              if (!novel) return;

              let markdown = `# ${novel.title}\n\n`;

              // Export Template first (optional placement, but good to have)
              markdown += `### Template\n\n`;
              markdown += `${getEffectiveTemplate(novel)}\n\n`; // Export effective template

              novel.chapters.forEach((chapter, chapterIndex) => {
                markdown += `## ${chapter.title}\n\n`;

                if (chapter.summary) {
                  markdown += `### Summary\n\n${chapter.summary}\n\n`;
                }

                markdown += `### Scene Beats\n\n`;
                chapter.sceneBeats.forEach((beat, beatIndex) => {
                  // Consistent numbering based on order
                  markdown += `#### Beat ${beatIndex + 1}\n\n`;
                  markdown += `**Scene Description:**\n${beat.text || ""}\n\n`; // Ensure newline even if empty
                  markdown += `**Generated Content:**\n${beat.generatedText || ""}\n\n`; // Ensure newline even if empty
                });
                // markdown += "\n"; // Removed extra newline after last beat
              });

              copyToClipboard(markdown.trim(), buttonElement);
            }

            function toggleImportArea() {
              const importArea = document.querySelector(".import-area");
              importArea.classList.toggle("show");
              if (!importArea.classList.contains("show")) {
                document.getElementById("importText").value = "";
              } else {
                document.getElementById("importText").focus();
              }
            }

            function importNovel() {
              const text = document.getElementById("importText").value; // Don't trim yet, preserve newlines
              if (!text) {
                alert("Please paste the exported novel markdown content first.");
                return;
              }

              try {
                const novel = {
                  id: generateId(),
                  title: "Imported Novel", // Default title
                  template: null, // Initialize template
                  chapters: [],
                };

                const lines = text.split('\n');
                let currentChapter = null;
                let currentBeat = null;
                let readingMode = null; // null | 'summary' | 'description' | 'generated' | 'template'
                let accumulatingText = ""; // Buffer for multi-line content

                lines.forEach((line) => {
                  const trimmedLine = line.trim();

                  // Check for section headers FIRST
                  if (trimmedLine.startsWith("# ")) {
                      finishAccumulatingText(); // Finish previous section
                      novel.title = trimmedLine.substring(2).trim();
                      readingMode = null;
                  } else if (trimmedLine.startsWith("## ")) {
                      finishAccumulatingText();
                      currentChapter = {
                          id: generateId(),
                          title: trimmedLine.substring(3).trim(),
                          summary: "",
                          sceneBeats: [],
                      };
                      novel.chapters.push(currentChapter);
                      currentBeat = null;
                      readingMode = null;
                  } else if (trimmedLine === "### Template") {
                      finishAccumulatingText();
                      readingMode = 'template';
                  } else if (trimmedLine === "### Summary" && currentChapter) {
                      finishAccumulatingText();
                      readingMode = 'summary';
                  } else if (trimmedLine === "### Scene Beats" && currentChapter) {
                      finishAccumulatingText();
                      readingMode = null; // End summary/template reading
                  } else if (trimmedLine.startsWith("#### Beat") && currentChapter) {
                      finishAccumulatingText();
                      currentBeat = {
                          id: generateId(),
                          text: "",
                          generatedText: "",
                      };
                      currentChapter.sceneBeats.push(currentBeat);
                      readingMode = null;
                  } else if (trimmedLine === "**Scene Description:**" && currentBeat) {
                      finishAccumulatingText();
                      readingMode = 'description';
                  } else if (trimmedLine === "**Generated Content:**" && currentBeat) {
                      finishAccumulatingText();
                      readingMode = 'generated';
                  } else {
                      // If not a header, it's content belonging to the current readingMode
                      accumulatingText += line + '\n';
                  }
                });

                // Finish the last section after the loop
                finishAccumulatingText();

                // Helper to assign accumulated text to the correct field
                function finishAccumulatingText() {
                    const content = accumulatingText.trim(); // Trim final content
                    if (readingMode === 'template') {
                        // Store template if it's not the default, otherwise store null
                         novel.template = (content && content !== DEFAULT_PROMPT_TEMPLATE) ? content : null;
                    } else if (readingMode === 'summary' && currentChapter) {
                        currentChapter.summary = content;
                    } else if (readingMode === 'description' && currentBeat) {
                        currentBeat.text = content;
                    } else if (readingMode === 'generated' && currentBeat) {
                        currentBeat.generatedText = content;
                    }
                    accumulatingText = ""; // Reset buffer
                }

                // Basic validation
                if (!novel.title || novel.title === "Imported Novel") {
                    console.warn("Imported novel might be missing title.");
                }
                if (novel.chapters.length === 0 && !novel.template) {
                   // Check if *anything* useful was parsed. The template check is important.
                    console.warn("Imported text didn't seem to contain chapter or template data.");
                    // Don't throw error yet, maybe user pasted something else
                }

                novels.push(novel);
                saveNovels();
                toggleImportArea(); // Close the import area
                renderNovelList(); // Refresh the list
                alert(`Novel "${novel.title}" imported successfully!`);
              } catch (e) {
                console.error("Import error:", e);
                alert(
                  "Error importing novel. Please check the format. It should be the Markdown exported from this tool.\n\n" + e.message
                );
              }
            }


            // --- Collapsible Summary State Management ---

            const LS_SUMMARY_STATE_KEY = "chapterSummaryStates";

            function getChapterSummaryStates() {
              try {
                // Ensure it returns an object
                const states = JSON.parse(localStorage.getItem(LS_SUMMARY_STATE_KEY) || "{}");
                return typeof states === 'object' && states !== null ? states : {};
              } catch (e) {
                console.error("Error reading summary states:", e);
                localStorage.removeItem(LS_SUMMARY_STATE_KEY); // Clear potentially corrupted data
                return {}; // Return empty object on error
              }
            }

            function saveChapterSummaryState(chapterId, isCollapsed) {
              const states = getChapterSummaryStates();
              states[chapterId] = isCollapsed; // true if collapsed, false if expanded
              try {
                localStorage.setItem(LS_SUMMARY_STATE_KEY, JSON.stringify(states));
              } catch (e) {
                console.error("Error saving summary state:", e);
                // Optionally alert the user if saving fails critically
              }
            }

            function removeChapterSummaryState(chapterId) {
              const states = getChapterSummaryStates();
              if (states.hasOwnProperty(chapterId)) {
                delete states[chapterId];
                try {
                  localStorage.setItem(LS_SUMMARY_STATE_KEY, JSON.stringify(states));
                } catch (e) {
                  console.error("Error removing summary state:", e);
                }
              }
            }

            // This function isn't strictly needed anymore as state is applied during renderNovelEditor
            // function initializeCollapsibleSummaries() { }

            function toggleChapterSummary(chapterId) {
              const summarySection = document.getElementById(`summary-section-${chapterId}`);
              const indicator = summarySection?.previousElementSibling?.querySelector(".collapse-indicator"); // Find indicator safely

              if (summarySection && indicator) {
                const isCurrentlyCollapsed = summarySection.classList.contains("collapsed");
                summarySection.classList.toggle("collapsed");
                const isNowCollapsed = !isCurrentlyCollapsed; // State after toggle

                // Update arrow direction visually
                indicator.style.transform = isNowCollapsed ? "rotate(-90deg)" : "";

                // Save the state to localStorage
                saveChapterSummaryState(chapterId, isNowCollapsed);
              } else {
                console.warn(
                  `Could not find summary section or indicator for chapter ${chapterId}`
                );
              }
            }

            // --- Initialization ---

            document.addEventListener("DOMContentLoaded", () => {
              loadNovels();
              showNovelList(); // Start by showing the list of novels
            });
    </script>
  </body>
</html>
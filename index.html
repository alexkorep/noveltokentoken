<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="manifest" href="manifest.json" />
    <meta name="theme-color" content="#4f46e5" />
    <title>NovelTokenToken</title>
    <style>
      *,
      *::before,
      *::after {
        box-sizing: border-box; /* Apply border-box universally */
      }

      /* --- Base & Variables --- */
      :root {
        --primary-color: #4f46e5; /* Indigo */
        --primary-color-hover: #4338ca;
        --danger-color: #dc2626; /* Red */
        --danger-color-hover: #b91c1c;
        --warning-color: #f59e0b; /* Amber */
        --warning-color-hover: #d97706;
        --secondary-color: #6b7280; /* Gray */
        --secondary-color-hover: #4b5563;
        --light-bg: #f9fafb; /* Very light gray */
        --medium-bg: #f3f4f6; /* Light gray */
        --container-bg: #ffffff;
        --text-color: #1f2937; /* Darker gray */
        --text-color-light: #6b7280; /* Medium gray */
        --border-color: #e5e7eb; /* Lighter gray border */
        --border-radius: 6px;
        --box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1),
          0 1px 2px -1px rgba(0, 0, 0, 0.1);
        --box-shadow-lg: 0 4px 6px -1px rgba(0, 0, 0, 0.1),
          0 2px 4px -2px rgba(0, 0, 0, 0.1);
      }

      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue",
          sans-serif;
        line-height: 1.6;
        margin: 0; /* Remove default margin */
        padding: 20px;
        background-color: var(--medium-bg);
        color: var(--text-color);
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      /* --- Typography --- */
      h1,
      h2,
      h3,
      h4 {
        color: var(--text-color);
        margin-top: 0;
        margin-bottom: 0.75em;
        line-height: 1.3;
      }
      h1 {
        font-size: 2em;
        font-weight: 600;
        margin-bottom: 1em;
      }
      h2 {
        font-size: 1.5em;
        font-weight: 600;
      }
      h3 {
        font-size: 1.25em;
        font-weight: 600;
      }
      h4 {
        font-size: 1.1em;
        font-weight: 600;
      }
      p {
        margin-bottom: 1em;
        /* Assuming default margin-top reset elsewhere or intended */
      }

      /* --- Layout --- */
      .container {
        max-width: 1200px;
        margin: 0 auto; /* Center container */
        background: var(--container-bg);
        padding: 25px;
        box-shadow: var(--box-shadow-lg);
        border-radius: var(--border-radius);
        overflow-x: hidden; /* Prevent horizontal overflow */
      }

      .view {
        margin-top: 25px;
        overflow-x: hidden; /* Prevent horizontal scroll */
        width: 100%; /* Ensure it doesn't exceed its parent */
      }

      /* Ensure text content wraps */
      .novel-item-title,
      .chapter-title,
      .beat-text-area,
      .generated-text-area-display,
      .scene-beat p {
        word-wrap: break-word;
        overflow-wrap: break-word;
      }

      hr {
        border: none;
        border-top: 1px solid var(--border-color);
        margin: 30px 0; /* More spacing */
      }

      /* --- Buttons --- */
      button {
        padding: 9px 15px;
        margin: 0; /* Reset margin, use gap or specific margins instead */
        cursor: pointer;
        background-color: var(--primary-color);
        color: white;
        border: none;
        border-radius: var(--border-radius);
        font-size: 0.9rem;
        font-weight: 500;
        transition: background-color 0.2s ease-in-out,
          box-shadow 0.2s ease-in-out;
        box-shadow: var(--box-shadow);
        vertical-align: middle; /* Align icons and text */
        white-space: nowrap; /* Prevent text wrapping by default */
      }

      button:hover {
        background-color: var(--primary-color-hover);
        box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.15);
      }

      button:focus {
        outline: 2px solid transparent;
        outline-offset: 2px;
        box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.4); /* Primary color focus ring */
      }
      button:focus:not(:focus-visible) {
        /* Remove focus ring if not keyboard focused */
        box-shadow: var(--box-shadow); /* Revert to base shadow */
      }

      button:disabled {
        background-color: #ccc;
        cursor: not-allowed;
        box-shadow: none;
        opacity: 0.7;
      }

      button.delete-btn {
        background-color: var(--danger-color);
      }
      button.delete-btn:hover {
        background-color: var(--danger-color-hover);
      }
      button.delete-btn:focus {
        box-shadow: 0 0 0 3px rgba(220, 38, 38, 0.4); /* Danger color focus ring */
      }
      button.delete-btn:focus:not(:focus-visible) {
        box-shadow: var(--box-shadow);
      }

      button.move-btn {
        background-color: var(--warning-color);
        font-weight: bold;
        padding: 5px 10px;
        min-width: 35px;
        font-size: 1rem; /* Make arrows slightly larger */
      }
      button.move-btn:hover {
        background-color: var(--warning-color-hover);
      }
      button.move-btn:focus {
        box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.4); /* Warning color focus ring */
      }
      button.move-btn:focus:not(:focus-visible) {
        box-shadow: var(--box-shadow);
      }

      button.secondary-btn {
        background-color: var(--secondary-color);
        color: white;
      }
      button.secondary-btn:hover {
        background-color: var(--secondary-color-hover);
      }
      button.secondary-btn:focus {
        box-shadow: 0 0 0 3px rgba(107, 114, 128, 0.4); /* Secondary color focus ring */
      }
      button.secondary-btn:focus:not(:focus-visible) {
        box-shadow: var(--box-shadow);
      }

      /* --- Input Fields & Textareas --- */
      input[type="text"],
      textarea {
        padding: 10px 12px;
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        font-size: 0.95rem;
        width: 100%;
        /* box-sizing is handled by universal selector */
        transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
      }

      input[type="text"]:focus,
      textarea:focus {
        border-color: var(--primary-color);
        outline: 2px solid transparent;
        outline-offset: 2px;
        box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.3); /* Primary color focus glow */
      }

      textarea {
        min-height: 60px;
        line-height: 1.5;
        resize: vertical;
      }

      /* --- Novel List View --- */
      #novelList {
        list-style: none;
        padding: 0;
        margin: 20px 0;
      }

      #novelList li {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px 20px; /* More padding */
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        margin-bottom: 10px;
        background-color: var(--container-bg);
        transition: box-shadow 0.2s ease-in-out, border-color 0.2s ease-in-out;
      }
      #novelList li:hover {
        border-color: #c7d2fe; /* Lighter primary on hover */
        box-shadow: var(--box-shadow);
      }

      .novel-item-title {
        font-weight: 600; /* Bolder title */
        cursor: pointer;
        color: var(--primary-color);
        font-size: 1.1em;
        flex-grow: 1;
        margin-right: 15px;
      }
      .novel-item-title:hover {
        text-decoration: underline;
        color: var(--primary-color-hover);
      }

      #novelList li div button {
        /* Reduce margin for buttons in list */
        margin-left: 8px;
      }

      /* Create/Import Novel Area */
      .create-import-area {
        display: flex;
        align-items: center;
        gap: 10px; /* Space between items */
        margin-top: 20px;
        padding: 15px;
        background-color: var(--light-bg);
        border-radius: var(--border-radius);
      }
      .create-import-area input[type="text"] {
        flex-grow: 1; /* Take available space */
      }

      /* --- Novel Editor View --- */
      .novel-title-edit input[type="text"] {
        font-size: 1.8em; /* Larger title */
        font-weight: 600;
        margin-bottom: 15px;
        padding: 12px 15px;
        border: none; /* No border unless focused */
        border-bottom: 2px solid transparent; /* Space for focus */
        border-radius: 0;
        width: 100%;
        box-shadow: none;
      }
      .novel-title-edit input[type="text"]:focus {
        border-bottom-color: var(--primary-color);
        box-shadow: none; /* Override general focus */
        background-color: var(--light-bg);
      }

      /* --- Chapter --- */
      .chapter {
        margin-bottom: 40px; /* Space between chapters */
        padding: 20px 15px;
        border-block: 1px solid var(--border-color);
        border-inline: none;
        border-radius: var(--border-radius);
        background-color: var(
          --container-bg
        ); /* White background for chapters */
        box-shadow: var(--box-shadow);
      }

      .chapter-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        flex-wrap: wrap;
        gap: 15px; /* Space between title and controls */
        padding-bottom: 15px;
        border-bottom: 1px solid var(--border-color);
      }

      .chapter-title {
        font-size: 1.3em; /* Slightly larger */
        font-weight: 600;
        border: none;
        padding: 8px 0; /* Padding only vertical */
        flex-grow: 1;
        margin-right: 10px;
        background: transparent;
        border-radius: 0;
        box-shadow: none;
        border-bottom: 2px solid transparent; /* For focus state */
        width: auto; /* Don't force full width */
      }
      .chapter-title:focus {
        outline: none;
        background-color: #f0f0ff; /* Light primary bg */
        border-bottom: 2px solid var(--primary-color);
        box-shadow: none;
      }

      .chapter-controls {
        display: flex;
        align-items: center;
        flex-shrink: 0; /* Prevent controls from shrinking too much */
        gap: 8px; /* Space between control buttons */
      }

      /* --- Scene Beat --- */
      .scene-beat {
        border: none;
        padding: 15px 10px;
        margin: 20px 0; /* Space between beats */
        background-color: var(
          --light-bg
        ); /* Light background to group beat content */
        border-radius: var(--border-radius);
        position: relative; /* For potential future decorations */
      }

      /* Style the instruction label */
      .scene-beat > p:first-of-type {
        margin-bottom: 8px;
        font-size: 0.9em;
        color: var(--text-color-light);
        font-weight: 500;
      }

      /* Instruction Text Area (Display) */
      .beat-text-area {
        padding: 10px;
        background-color: #e0e7ff; /* Slightly different light blue for instructions */
        border-block: 1px solid #c7d2fe;
        border-inline: none;
        border-radius: var(--border-radius);
        min-height: 60px;
        white-space: pre-wrap;
        width: 100%;
        color: var(--text-color);
        line-height: 1.5;
        margin-bottom: 15px; /* Space before controls */
      }

      .beat-controls {
        display: flex;
        justify-content: flex-end;
        align-items: center;
        margin-top: 10px;
        margin-bottom: 20px; /* Space before generated text */
        flex-wrap: wrap;
        gap: 8px; /* Space between beat control buttons */
      }

      /* Style the generated content label */
      .scene-beat > p:nth-of-type(2) {
        margin-top: 20px; /* Space above label */
        margin-bottom: 8px;
        font-size: 0.9em;
        color: var(--text-color-light);
        font-weight: 500;
      }

      /* Generated Text Display */
      .generated-text-area-display {
        padding: 12px;
        background-color: #ffffff; /* White background like main container */
        border-block: 1px solid var(--border-color);
        border-inline: none;
        border-radius: var(--border-radius);
        min-height: 80px;
        white-space: pre-wrap;
        color: var(--text-color);
        line-height: 1.6;
        font-size: 1rem; /* Slightly larger for readability */
        margin-bottom: 10px; /* Space before edit button */
      }

      /* Generated text edit button alignment */
      .generated-text-edit-controls {
        text-align: right;
        margin-top: 5px;
      }

      /* --- Add Beat Area --- */
      .add-beat-area {
        margin-top: 25px;
        padding: 20px;
        background-color: var(--medium-bg);
        border-radius: var(--border-radius);
        display: flex;
        align-items: flex-start; /* Align top */
        gap: 10px;
      }

      .add-beat-area textarea {
        flex-grow: 1;
        min-height: 50px; /* Slightly taller */
      }
      .add-beat-area button {
        flex-shrink: 0; /* Prevent button from shrinking */
      }

      /* --- Chapter Summary --- */
      .summary-section {
        transition: max-height 0.3s ease-out, opacity 0.3s ease-out,
          margin-top 0.3s ease-out;
        overflow: hidden;
        max-height: 1000px; /* Large enough for content */
        opacity: 1;
        margin-top: 15px;
      }

      .summary-section.collapsed {
        max-height: 0;
        opacity: 0;
        margin-top: 0;
        /* Hide elements inside instantly to prevent interaction */
        pointer-events: none;
      }
      .summary-section.collapsed > * {
        visibility: hidden;
      }

      .summary-header {
        display: flex;
        align-items: center;
        cursor: pointer;
        gap: 8px;
        padding: 10px 0;
        border-top: 1px solid var(--border-color);
        margin-top: 30px; /* Separate from beats */
        user-select: none; /* Prevent text selection on click */
      }
      .summary-header:hover h4 {
        color: var(--primary-color);
      }

      .summary-header h4 {
        margin: 0;
        color: var(--text-color-light);
        transition: color 0.2s ease-in-out;
        font-weight: 600;
      }

      .collapse-indicator {
        font-size: 16px;
        line-height: 1;
        transition: transform 0.3s;
        display: inline-block;
        color: var(--text-color-light);
      }
      .summary-header:not(.collapsed) .collapse-indicator {
        transform: rotate(0deg); /* Keep explicit for transition */
      }
      .summary-header.collapsed .collapse-indicator {
        transform: rotate(-90deg);
      }

      .summary-controls {
        margin-bottom: 10px;
      }
      .summary-text-area {
        min-height: 120px; /* Taller summary area */
        background-color: var(--container-bg);
        padding-inline: 8px; /* Use shorthand */
      }

      /* --- Feedback --- */
      .feedback-container {
        display: inline-block;
        min-width: 70px; /* Prevent layout shift */
        text-align: left;
        margin-left: 10px;
        vertical-align: middle;
      }
      .feedback {
        color: #16a34a; /* Green */
        font-size: 0.9em;
        font-weight: 500;
        opacity: 0;
        transition: opacity 0.3s ease-out;
      }
      .feedback.show {
        opacity: 1;
      }

      /* --- Modal Dialog Styles --- */
      .modal-overlay {
        position: fixed;
        inset: 0; /* Shorthand for top/left/right/bottom */
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.6); /* Darker overlay */
        z-index: 1000;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 10px; /* Reduced padding for smaller screens */
        opacity: 0; /* Start hidden for animation */
        animation: fadeIn 0.2s ease-out forwards;
      }
      @keyframes fadeIn {
        to {
          opacity: 1;
        }
      }

      .modal-dialog {
        background-color: var(--container-bg);
        max-width: 95%; /* Allow more width on small screens */
        width: 800px;
        max-height: 90vh; /* Allow slightly more height */
        border-radius: var(--border-radius);
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1),
          0 4px 6px -4px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-direction: column;
        transform: scale(0.95); /* Start slightly small for animation */
        opacity: 0;
        animation: zoomIn 0.2s 0.1s ease-out forwards;
      }
      @keyframes zoomIn {
        to {
          transform: scale(1);
          opacity: 1;
        }
      }

      .modal-header {
        padding: 15px 20px;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
      }

      .modal-title {
        font-size: 1.2em;
        font-weight: 600;
        margin: 0;
      }

      .modal-close {
        background: none;
        border: none;
        font-size: 1.8em; /* Larger close button */
        cursor: pointer;
        color: var(--text-color-light);
        padding: 0 5px; /* Easier to click */
        margin: -5px -5px -5px 0; /* Adjust position slightly */
        line-height: 1;
        transition: color 0.2s ease-in-out;
      }
      .modal-close:hover {
        color: var(--text-color);
      }

      .modal-body {
        padding: 15px; /* Slightly reduced padding */
        overflow-y: auto;
        flex-grow: 1;
      }

      .modal-footer {
        padding: 15px 20px;
        border-top: 1px solid var(--border-color);
        display: flex;
        justify-content: flex-end;
        background-color: var(--light-bg); /* Subtle footer background */
        border-bottom-left-radius: var(--border-radius);
        border-bottom-right-radius: var(--border-radius);
        flex-shrink: 0;
        gap: 10px; /* Space between footer buttons */
      }

      .prompt-textarea {
        width: 100%;
        min-height: 350px; /* Taller text area */
        font-family: "Menlo", "Monaco", "Consolas", monospace; /* Monospace for prompts */
        font-size: 0.9rem;
        padding: 15px 10px;
        border-block: 1px solid var(--border-color);
        border-inline: none;
        border-radius: var(--border-radius);
        margin-bottom: 10px;
        resize: vertical;
        background-color: var(--light-bg); /* Light bg for readonly textareas */
      }
      .prompt-textarea:not([readOnly]) {
        background-color: var(--container-bg); /* White if editable */
      }

      /* --- Settings Styles (Template Help) --- */
      .template-help {
        font-size: 0.9em;
        color: var(--text-color-light);
        margin-top: 15px;
        padding: 10px;
        background-color: var(--medium-bg);
        border-radius: var(--border-radius);
      }
      .template-help p {
        margin-bottom: 5px;
      }
      .template-help ul {
        margin: 5px 0 0 20px;
        padding: 0;
      }
      .template-help code {
        background-color: #e5e7eb;
        padding: 2px 5px;
        border-radius: 4px;
        font-family: "Menlo", "Monaco", "Consolas", monospace;
        color: var(--primary-color);
      }

      /* Novel Text Modal Specifics */
      .novel-text-display {
        white-space: pre-wrap;
        font-family: "Georgia", "Times New Roman", Times, serif; /* Serif for novel text */
        line-height: 1.7;
        padding: 15px 10px;
        background-color: #fff;
        border-block: 1px solid var(--border-color);
        border-inline: none;
        border-radius: var(--border-radius);
        font-size: 1rem;
        color: #333; /* Slightly lighter black for reading */
      }
      .novel-text-modal-body {
        max-height: 65vh;
        overflow-y: auto;
        padding: 5px; /* Padding around the scrollable area */
      }

      /* --- Novel Editor View Header --- */
      .novel-editor-header {
        display: flex;
        align-items: center;
        flex-wrap: wrap; /* Allow wrapping on small screens */
        gap: 10px; /* Adjust spacing between elements */
        margin-bottom: 20px; /* Space below the header */
        padding: 10px; /* Optional padding around the header */
        background-color: var(
          --light-bg
        ); /* Light background for the header area */
        border-radius: var(--border-radius);
        border: 1px solid var(--border-color);
      }

      .novel-editor-header .back-button {
        flex-shrink: 0; /* Prevent back button from shrinking */
        padding: 8px 10px; /* Slightly smaller padding */
      }

      /* Adjust Novel Title Input for Header */
      .novel-editor-header .novel-title-edit {
        flex-grow: 1; /* Allow title to take up available space */
        margin: 0; /* Remove default margin */
        min-width: 150px; /* Reduced min-width */
      }
      .novel-editor-header .novel-title-edit input[type="text"] {
        font-size: 1.2em; /* Slightly smaller in header */
        font-weight: 600;
        padding: 8px 10px; /* Adjust padding */
        margin-bottom: 0; /* Remove bottom margin */
        border: 1px solid var(--border-color); /* Add subtle border */
        background-color: var(--container-bg); /* White background */
        box-shadow: none;
      }
      .novel-editor-header .novel-title-edit input[type="text"]:focus {
        border-color: var(--primary-color); /* Keep focus style */
        box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.3);
        background-color: var(--container-bg);
      }

      /* Group Action Buttons */
      .novel-editor-header .action-buttons {
        display: flex;
        align-items: center;
        gap: 6px; /* Reduced gap */
        flex-shrink: 0; /* Prevent buttons shrinking too much */
        flex-wrap: wrap; /* Allow buttons to wrap */
      }
      .novel-editor-header .action-buttons button {
        padding: 8px 10px; /* Make buttons slightly smaller */
        font-size: 0.85rem;
      }

      /* Group Chapter Filter */
      .novel-editor-header .chapter-filter-group {
        display: flex;
        align-items: center;
        gap: 5px; /* Space between label and select */
        flex-shrink: 0;
      }
      .novel-editor-header .chapter-filter-group label {
        font-size: 0.9em;
        color: var(--text-color-light);
        margin: 0;
        white-space: nowrap; /* Prevent label wrapping */
      }
      .novel-editor-header .chapter-filter-group select {
        padding: 7px 10px; /* Adjust padding */
        font-size: 0.9em;
        min-width: 130px; /* Reduced min-width */
        border: 1px solid var(--border-color); /* Style consistency */
        border-radius: var(--border-radius); /* Style consistency */
        background-color: var(--container-bg); /* Style consistency */
      }

      /* Push Delete Button to the Right */
      .novel-editor-header .delete-novel-btn {
        margin-left: auto; /* Magic! Pushes it to the end */
        flex-shrink: 0;
        padding: 8px 10px; /* Match other header buttons */
        font-size: 0.85rem;
      }

      /* Remove original containers if they are now empty */
      .import-export-area,
      .chapter-filter {
        margin: 0;
        padding: 0;
        background: none;
        border: none;
      }

      /* Responsive Button Text */
      .button-text-desktop {
        display: inline;
      }
      .button-text-mobile {
        display: none;
      }
      .button-icon {
        vertical-align: middle;
        margin-right: 4px; /* Default margin */
      }
      .button-icon:only-child {
        margin-right: 0; /* No margin if only icon */
      }

      /* === MEDIA QUERIES for Mobile Responsiveness === */

      @media (max-width: 900px) {
        .button-text-desktop {
          display: none;
        }
        .button-text-mobile {
          display: inline;
        }
        .button-icon {
          margin-right: 0; /* Remove margin when text is hidden */
        }
        .novel-editor-header .novel-title-edit input[type="text"] {
          font-size: 1.2em; /* Slightly smaller title */
        }
        .novel-editor-header .action-buttons button,
        .novel-editor-header .back-button,
        .novel-editor-header .delete-novel-btn {
          padding: 8px; /* Icon only padding */
        }
        .novel-editor-header .action-buttons button .button-icon,
        .novel-editor-header .back-button .button-icon,
        .novel-editor-header .delete-novel-btn .button-icon {
          margin-right: 0;
        }
      }

      /* --- Specific Mobile Padding/Border Reductions --- */
      @media (max-width: 768px) {
        body {
          padding: 10px; /* Further reduce body padding */
        }
        .container {
          padding: 15px; /* Reduce container padding */
        }
        .chapter {
          padding: 15px 5px;
          border-block: 1px solid var(--border-color);
          border-inline: none;
          border-radius: var(--border-radius); /* Keep if desired */
          border-top-left-radius: var(--border-radius);
          border-top-right-radius: var(--border-radius);
          border-bottom-left-radius: var(--border-radius);
          border-bottom-right-radius: var(--border-radius);
        }
        .scene-beat {
          padding: 10px 5px;
          margin-inline: 0; /* Remove margin if chapter padding is less */
        }
        .beat-text-area,
        .generated-text-area-display,
        .summary-text-area,
        .prompt-textarea,
        .novel-text-display {
          padding-inline: 8px;
        }

        .novel-editor-header {
          gap: 8px;
        }
        .novel-editor-header .novel-title-edit {
          min-width: 120px; /* Allow title to shrink more */
        }
        .novel-editor-header .chapter-filter-group select {
          min-width: 100px; /* Allow filter to shrink more */
        }
        .novel-editor-header .back-button span {
          display: none; /* Hide "Back" text */
        }
        .novel-editor-header .back-button {
          padding: 8px; /* Icon only padding */
        }
        .novel-editor-header .back-button .button-icon {
          margin-right: 0;
        }
        #novelList li {
          padding: 12px 10px;
          flex-direction: column; /* Stack title and buttons */
          align-items: flex-start;
          gap: 8px; /* Add gap for stacked items */
        }
        .novel-item-title {
          margin-right: 0;
        }
        #novelList li div {
          width: 100%;
          text-align: right; /* Align buttons right */
        }
        #novelList li div button {
          margin-left: 5px; /* Adjust button spacing */
        }

        .create-import-area {
          flex-direction: column; /* Stack input and buttons */
          align-items: stretch; /* Make items full width */
          padding: 10px;
          gap: 8px;
        }
      }

      @media (max-width: 480px) {
        body {
          padding: 5px;
        }
        .container {
          padding: 10px;
          border-radius: 0;
          width: 100%;
          max-width: none;
          border: none; /* Remove border/shadow on smallest screens */
          box-shadow: none;
        }
        .chapter {
          padding: 10px 0px; /* Minimal horizontal padding */
          border-radius: 0;
          width: 100%;
          border-inline: none;
          box-shadow: none; /* Simplify appearance */
        }
        .scene-beat {
          padding: 8px 0;
          border-radius: 0;
          width: 100%;
          background-color: transparent; /* Remove bg color */
        }
        h1 {
          font-size: 1.6em;
        }
        h2 {
          font-size: 1.3em;
        }
        h3 {
          font-size: 1.15em;
        }

        button {
          padding: 8px 12px;
          font-size: 0.85rem;
        }
        button.move-btn {
          padding: 4px 8px;
          min-width: 30px;
          font-size: 0.9rem;
        }
        .novel-editor-header {
          padding: 8px;
          border-radius: 0;
        }
        .novel-editor-header .action-buttons button,
        .novel-editor-header .back-button,
        .novel-editor-header .delete-novel-btn {
          padding: 6px; /* Further reduce icon padding */
        }
        .novel-editor-header .novel-title-edit input[type="text"] {
          font-size: 1.1em;
        }
        input[type="text"],
        textarea {
          max-width: 100%; /* Prevent them from ever exceeding container */
        }
        .modal-dialog {
          max-width: 100%;
          width: 100%;
          height: 100%;
          max-height: 100vh;
          border-radius: 0;
          box-shadow: none;
        }
      }

      .import-button,
      .import-area .secondary-btn {
        margin: 10px;
      }

      /* --- END MEDIA QUERIES --- */

      /* --- Added Firebase Styles --- */
      .auth-container {
        display: flex;
        align-items: center;
        justify-content: flex-end; /* Align to the right */
        padding: 5px 0 15px; /* Add some padding */
        gap: 10px;
        flex-wrap: wrap; /* Allow wrapping */
        border-bottom: 1px solid var(--border-color);
        margin-bottom: 20px;
      }
      .user-info img {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        vertical-align: middle;
        margin-right: 8px;
      }
      .user-info span {
        vertical-align: middle;
        font-size: 0.9em;
        color: var(--text-color-light);
      }
      .loading-indicator {
        text-align: center;
        padding: 40px;
        font-size: 1.2em;
        color: var(--text-color-light);
      }
      .login-prompt {
        text-align: center;
        padding: 30px;
        background-color: var(--light-bg);
        border-radius: var(--border-radius);
        margin-top: 20px;
      }
      .login-prompt p {
        margin-bottom: 15px;
        color: var(--text-color-light);
      }
    </style>
  </head>
  <body>
    <!-- Root element for React -->
    <div id="root"></div>

    <!-- React and Babel CDNs -->
    <script
      src="https://unpkg.com/react@18/umd/react.development.js"
      crossorigin
    ></script>
    <script
      src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
      crossorigin
    ></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

    <!-- Firebase SDKs (Using compat libraries for easier integration with potential older patterns) -->
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>

    <!-- Firebase Initialization -->
    <script>
      // --- IMPORTANT: REPLACE WITH YOUR ACTUAL FIREBASE CONFIG ---
      const firebaseConfig = {
        apiKey: "AIzaSyA0TaS0k2IU0ZomZ_WWScv7b4P3y2odyZk",
        authDomain: "noveltokentoken.firebaseapp.com",
        projectId: "noveltokentoken",
        storageBucket: "noveltokentoken.firebasestorage.app",
        messagingSenderId: "775614082958",
        appId: "1:775614082958:web:033c020f78c43d4ca47edf",
      };

      let auth, db, googleProvider;
      try {
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        auth = firebase.auth();
        db = firebase.firestore();
        googleProvider = new firebase.auth.GoogleAuthProvider();
        console.log("Firebase Initialized Successfully");
      } catch (error) {
        console.error("Firebase Initialization Error:", error);
        // Display error to the user in the UI if #root exists
        const rootEl = document.getElementById("root");
        if (rootEl) {
          rootEl.innerHTML = `<div style="color: red; padding: 20px; border: 1px solid red; background-color: #ffebee;">
                  <h2>Firebase Initialization Failed</h2>
                  <p>Could not connect to Firebase. Please check the console for errors and ensure your firebaseConfig is correct in the HTML.</p>
                  <p>Error: ${error.message}</p>
              </div>`;
        }
      }
    </script>

    <!-- React Application Code (using Babel) -->
    <script type="text/babel">
      const { useState, useEffect, useCallback, useMemo, useRef } = React;

      // --- Constants ---
      const LS_KEY = "novels_react_local_backup"; // Changed key to indicate backup role
      const LS_SUMMARY_STATE_KEY = "chapterSummaryStates_react_local_backup";
      const DEFAULT_PROMPT_TEMPLATE = `The story so far:
{storySoFar}

You are an expert fiction writer. Continue the story and write about 400 words for the following instructions:
{instructions}

NEVER conclude the scene on your own, follow the beat instructions very closely. NEVER end with foreshadowing. NEVER write further than what I prompt you with. AVOID imagining possible endings, NEVER deviate from the instructions.

STOP EARLY if the continuation contains what was required in the instructions. You do not need to fill out the full amount of words possible.

- Do not use bold or italic font.
- Write in active voice.`;

      // --- Helper Functions ---
      function generateId() {
        return (
          Date.now().toString(36) + Math.random().toString(36).substring(2)
        );
      }

      function getEffectiveTemplate(novel) {
        return (novel && novel.template) || DEFAULT_PROMPT_TEMPLATE;
      }

      function copyToClipboard(text) {
        if (!text) return Promise.reject(new Error("Nothing to copy"));
        return navigator.clipboard.writeText(text);
      }

      function findChapeter(novel, chapterId) {
        // Typo: Chapter*
        if (!novel || !novel.chapters) return null;
        return novel.chapters.find((chapter) => chapter.id === chapterId);
      }

      // Simple debounce function
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Data validation function (can be expanded)
      function validateAndCleanNovels(loadedNovels) {
        if (!Array.isArray(loadedNovels)) {
          console.warn("Loaded novels data is not an array, resetting.");
          return [];
        }
        // Basic validation/migration (ensure arrays/fields exist)
        loadedNovels.forEach((novel) => {
          if (typeof novel !== "object" || novel === null) return; // Skip invalid entries
          novel.id = novel.id || generateId();
          novel.title = novel.title || "Untitled Novel";
          // Ensure 'template' exists, even if null
          novel.template = novel.template === undefined ? null : novel.template;
          novel.chapters = Array.isArray(novel.chapters) ? novel.chapters : [];
          novel.chapters.forEach((chapter) => {
            if (typeof chapter !== "object" || chapter === null) return;
            chapter.id = chapter.id || generateId();
            chapter.title = chapter.title || "Untitled Chapter";
            chapter.summary = chapter.summary || "";
            chapter.sceneBeats = Array.isArray(chapter.sceneBeats)
              ? chapter.sceneBeats
              : [];
            chapter.sceneBeats.forEach((beat) => {
              if (typeof beat !== "object" || beat === null) return;
              beat.id = beat.id || generateId();
              beat.text = beat.text || "";
              beat.generatedText = beat.generatedText || "";
            });
          });
        });
        return loadedNovels;
      }

      // --- Modal Component --- (Existing, Unchanged)
      function Modal({ title, children, footer, onClose }) {
        useEffect(() => {
          const handleKeyDown = (event) => {
            if (event.key === "Escape") {
              onClose();
            }
          };
          document.addEventListener("keydown", handleKeyDown);
          return () => {
            document.removeEventListener("keydown", handleKeyDown);
          };
        }, [onClose]); // Re-add listener if onClose changes

        return (
          <div className="modal-overlay" onClick={onClose}>
            {" "}
            {/* Close on overlay click */}
            <div className="modal-dialog" onClick={(e) => e.stopPropagation()}>
              {" "}
              {/* Prevent closing when clicking inside dialog */}
              <div className="modal-header">
                <h3 className="modal-title">{title}</h3>
                <button className="modal-close" onClick={onClose}>
                  ×
                </button>
              </div>
              <div className="modal-body">{children}</div>
              <div className="modal-footer">{footer}</div>
            </div>
          </div>
        );
      }

      // --- Feedback Component ---
      function FeedbackMessage({ show, message = "Copied!" }) {
        return (
          <span className={`feedback ${show ? "show" : ""}`}>{message}</span>
        );
      }

      // --- SceneBeat Component ---
      function SceneBeat({
        novelId,
        chapterId,
        beat,
        beatIndex,
        totalBeats,
        onUpdateGeneratedText,
        onDeleteBeat,
        onMoveBeat,
        onShowPrompt,
        onEditBeat,
        onShowEditGeneratedTextModal,
      }) {
        return (
          <div className="scene-beat">
            <p
              style={{ marginBottom: "2px", fontSize: "0.9em", color: "#555" }}
            >
              <strong>Scene Beat Instruction:</strong>
            </p>
            {/* Display beat text as static paragraph */}
            <p
              className="beat-text-area"
              style={{
                padding: "8px",
                backgroundColor: "#f5f5f5",
                borderRadius: "4px",
                minHeight: "60px",
                whiteSpace: "pre-wrap",
                width: "100%" /* Make full width */,
                boxSizing:
                  "border-box" /* Include padding in width calculation */,
              }}
            >
              {beat.text || ""}
            </p>

            <div className="beat-controls">
              <button
                className="move-btn"
                onClick={() => onMoveBeat(novelId, chapterId, beat.id, -1)}
                disabled={beatIndex === 0}
              >
                ↑
              </button>
              <button
                className="move-btn"
                onClick={() => onMoveBeat(novelId, chapterId, beat.id, 1)}
                disabled={beatIndex === totalBeats - 1}
              >
                ↓
              </button>
              <button onClick={() => onEditBeat(novelId, chapterId, beat.id)}>
                Edit Instruction
              </button>
              <button onClick={() => onShowPrompt(novelId, chapterId, beat.id)}>
                Show Prompt
              </button>
              <button
                className="delete-btn"
                onClick={() => onDeleteBeat(novelId, chapterId, beat.id)}
              >
                Delete Beat
              </button>
            </div>

            <p
              style={{
                marginTop: "10px",
                marginBottom: "2px",
                fontSize: "0.9em",
                color: "#555",
              }}
            >
              <strong>AI Generated Content:</strong>
            </p>
            <div className="generated-text-area-display">
              {beat.generatedText}
            </div>
            <div style={{ textAlign: "right", marginTop: "5px" }}>
              <button
                onClick={() =>
                  onShowEditGeneratedTextModal(
                    novelId,
                    chapterId,
                    beat.id,
                    beat.generatedText
                  )
                }
                style={{ marginLeft: "5px" }}
              >
                Edit Content
              </button>
            </div>
          </div>
        );
      }

      // --- ChapterSummary Component ---
      function ChapterSummary({
        novelId,
        chapter,
        isCollapsed,
        onToggleCollapse,
        onUpdateSummary,
        onCopySummaryPrompt,
      }) {
        const [copyFeedback, setCopyFeedback] = useState(false);

        const handleCopyPrompt = () => {
          onCopySummaryPrompt(novelId, chapter.id)
            .then(() => {
              setCopyFeedback(true);
              setTimeout(() => setCopyFeedback(false), 1500);
            })
            .catch((err) => {
              console.error("Failed to copy summary prompt:", err);
              alert("Failed to copy. See console for details.");
            });
        };

        return (
          <div>
            <div
              className={`summary-header ${isCollapsed ? "collapsed" : ""}`}
              onClick={() => onToggleCollapse(chapter.id)}
            >
              <span className="collapse-indicator">▼</span>
              <h4>Chapter Summary</h4>
            </div>
            <div
              className={`summary-section ${isCollapsed ? "collapsed" : ""}`}
            >
              <button onClick={handleCopyPrompt}>Copy Summary Prompt</button>
              <div className="feedback-container">
                <FeedbackMessage show={copyFeedback} />
              </div>
              <textarea
                className="summary-text-area"
                placeholder="Paste chapter summary generated by AI here..."
                value={chapter.summary || ""}
                onChange={(e) =>
                  onUpdateSummary(novelId, chapter.id, e.target.value)
                }
              />
            </div>
          </div>
        );
      }

      // --- Chapter Component --- (Existing, Unchanged)
      function Chapter({
        novelId,
        chapter,
        chapterIndex,
        totalChapters,
        onUpdateChapterTitle,
        onDeleteChapter,
        onMoveChapter,
        onAddBeat,
        onUpdateGeneratedText,
        onDeleteBeat,
        onMoveBeat,
        onShowPrompt,
        isSummaryCollapsed,
        onToggleSummaryCollapse,
        onUpdateChapterSummary,
        onCopySummaryPrompt,
        onEditBeat,
        onShowEditGeneratedTextModal,
      }) {
        const [newBeatText, setNewBeatText] = useState("");

        const handleAddBeat = () => {
          if (!newBeatText.trim()) {
            alert("Please enter some text for the scene beat instruction.");
            return;
          }
          onAddBeat(novelId, chapter.id, newBeatText);
          setNewBeatText(""); // Clear input after adding
        };

        return (
          <div className="chapter">
            <div className="chapter-header">
              <input
                type="text"
                className="chapter-title"
                value={chapter.title || ""}
                onChange={(e) =>
                  onUpdateChapterTitle(novelId, chapter.id, e.target.value)
                }
                placeholder="Chapter Title"
              />
              <div className="chapter-controls">
                <button
                  className="move-btn"
                  onClick={() => onMoveChapter(novelId, chapter.id, -1)}
                  disabled={chapterIndex === 0}
                >
                  ↑
                </button>
                <button
                  className="move-btn"
                  onClick={() => onMoveChapter(novelId, chapter.id, 1)}
                  disabled={chapterIndex === totalChapters - 1}
                >
                  ↓
                </button>
                <button
                  className="delete-btn"
                  onClick={() => onDeleteChapter(novelId, chapter.id)}
                >
                  Delete Chapter
                </button>
              </div>
            </div>

            <div className="scene-beats-container">
              {chapter.sceneBeats.length === 0 ? (
                <p style={{ color: "#888", fontStyle: "italic" }}>
                  No scene beats yet.
                </p>
              ) : (
                chapter.sceneBeats.map((beat, index) => (
                  <SceneBeat
                    key={beat.id}
                    novelId={novelId}
                    chapterId={chapter.id}
                    beat={beat}
                    beatIndex={index}
                    totalBeats={chapter.sceneBeats.length}
                    onUpdateGeneratedText={onUpdateGeneratedText}
                    onDeleteBeat={onDeleteBeat}
                    onMoveBeat={onMoveBeat}
                    onShowPrompt={onShowPrompt}
                    onEditBeat={onEditBeat}
                    onShowEditGeneratedTextModal={onShowEditGeneratedTextModal}
                  />
                ))
              )}
            </div>

            <div className="add-beat-area">
              <textarea
                className="new-beat-text"
                placeholder="Add new scene beat instruction..."
                value={newBeatText}
                onChange={(e) => setNewBeatText(e.target.value)}
              />
              <button onClick={handleAddBeat}>+ Add Beat</button>
            </div>

            <hr style={{ margin: "15px 0" }} />

            <ChapterSummary
              novelId={novelId}
              chapter={chapter}
              isCollapsed={isSummaryCollapsed}
              onToggleCollapse={onToggleSummaryCollapse}
              onUpdateSummary={onUpdateChapterSummary}
              onCopySummaryPrompt={onCopySummaryPrompt}
            />
          </div>
        );
      }

      // --- NovelEditorView Component ---
      function NovelEditorView({
        novel,
        onBack,
        onUpdateNovel,
        onDeleteNovel,
        onAddChapter,
        onDeleteChapter,
        onMoveChapter,
        onUpdateChapterTitle,
        onAddBeat,
        onDeleteBeat,
        onMoveBeat,
        onUpdateBeatText,
        onUpdateGeneratedText,
        onUpdateChapterSummary,
        onExportNovel,
        onShowPrompt,
        onShowTemplateEditor,
        summaryCollapseStates,
        onToggleSummaryCollapse,
        onCopySummaryPrompt,
        onEditBeat,
        onShowEditGeneratedTextModal,
        handleViewNovelText,
      }) {
        const [exportFeedback, setExportFeedback] = useState(false);
        const [chapterFilter, setChapterFilter] = useState("all");

        const handleExport = () => {
          onExportNovel(novel.id)
            .then(() => {
              setExportFeedback(true);
              setTimeout(() => setExportFeedback(false), 1500);
            })
            .catch((err) => {
              console.error("Export failed:", err);
              alert("Export failed. See console for details.");
            });
        };

        const filteredChapters = useMemo(() => {
          if (!novel || !Array.isArray(novel.chapters)) return [];
          if (chapterFilter === "all") {
            return novel.chapters;
          }
          return novel.chapters.filter((ch) => ch.id === chapterFilter);
        }, [novel.chapters, chapterFilter]);

        // Reset filter if the selected chapter is deleted or novel changes
        useEffect(() => {
          if (
            chapterFilter !== "all" &&
            !novel.chapters.find((ch) => ch.id === chapterFilter)
          ) {
            setChapterFilter("all");
          }
        }, [novel.chapters, chapterFilter]);

        if (!novel) {
          return (
            <div>
              Error: Novel not found.{" "}
              <button onClick={onBack}>Back to List</button>
            </div>
          ); // Handle case where novel might become null
        }

        return (
          <div className="view" id="novelEditorView">
            {/* Novel Editor Header */}
            <div className="novel-editor-header">
              <button onClick={onBack} className="back-button">
                ← <span className="button-text-desktop">Back to List</span>
              </button>

              <div className="novel-title-edit">
                <input
                  type="text"
                  id="editNovelTitle"
                  value={novel.title || ""}
                  onChange={(e) =>
                    onUpdateNovel(novel.id, { title: e.target.value })
                  }
                  placeholder="Novel Title"
                />
              </div>

              <div className="action-buttons">
                <button onClick={handleExport} title="Export Novel">
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 20 20"
                    fill="currentColor"
                    width="16"
                    height="16"
                    style={{ verticalAlign: "middle", marginRight: "4px" }}
                  >
                    <path d="M10.75 2.75a.75.75 0 0 0-1.5 0v8.614L6.295 8.235a.75.75 0 1 0-1.09 1.03l4.25 4.5a.75.75 0 0 0 1.09 0l4.25-4.5a.75.75 0 0 0-1.09-1.03l-2.955 3.129V2.75Z" />
                    <path d="M3.5 12.75a.75.75 0 0 0-1.5 0v2.5A2.75 2.75 0 0 0 4.75 18h10.5A2.75 2.75 0 0 0 18 15.25v-2.5a.75.75 0 0 0-1.5 0v2.5c0 .69-.56 1.25-1.25 1.25H4.75c-.69 0-1.25-.56-1.25-1.25v-2.5Z" />
                  </svg>
                  <span className="button-text-mobile">Export</span>
                  <span className="button-text-desktop">Export Novel</span>
                </button>
                <button
                  onClick={() => onShowTemplateEditor(novel.id)}
                  title="Edit Prompt Template"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 20 20"
                    fill="currentColor"
                    width="16"
                    height="16"
                    style={{ verticalAlign: "middle", marginRight: "4px" }}
                  >
                    <path d="M17.435 2.565a.75.75 0 0 0-1.06 0l-11.5 11.5a.75.75 0 0 0 0 1.06l3 3a.75.75 0 0 0 1.06 0l11.5-11.5a.75.75 0 0 0 0-1.06l-3-3ZM16.06 4.344l1.656 1.656L6.343 17.373l-1.656-1.656L16.061 4.344ZM4.939 16.061 3.283 14.404 14.404 3.283l1.656 1.656L4.94 16.06Z" />
                    <path d="M1.5 17.75a.75.75 0 0 0 0 1.5h14.5a.75.75 0 0 0 0-1.5H1.5Z" />
                  </svg>
                  <span className="button-text-mobile">Template</span>
                  <span className="button-text-desktop">Edit Template</span>
                </button>
                <button
                  onClick={() => handleViewNovelText(novel.id)}
                  title="View Novel Text"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 20 20"
                    fill="currentColor"
                    width="16"
                    height="16"
                    style={{ verticalAlign: "middle", marginRight: "4px" }}
                  >
                    <path d="M.99 6.002c0-.551.444-.998.995-.998h16.03c.55 0 .995.447.995.998v7.996a.998.998 0 0 1-.995.998H1.985a.998.998 0 0 1-.995-.998V6.002Zm1.99.998v6.001h14.03V7.000H2.98Z" />
                    <path d="M4 4.002c0-.551.444-.998.995-.998h10.01a.998.998 0 0 1 .995.998v.998a.75.75 0 0 1-1.5 0v-.998H5.495v.998a.75.75 0 0 1-1.5 0V4.002Z" />
                  </svg>
                  <span className="button-text-mobile">View</span>
                  <span className="button-text-desktop">View Text</span>
                </button>
                <a
                  href="./manual.html"
                  target="_blank"
                  rel="noopener noreferrer"
                  title="User Manual"
                >
                  <button>
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      viewBox="0 0 20 20"
                      fill="currentColor"
                      width="16"
                      height="16"
                      style={{ verticalAlign: "middle" }}
                    >
                      <path
                        fillRule="evenodd"
                        d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-4a.75.75 0 01.75.75v.008a.75.75 0 01-1.5 0V6.75A.75.75 0 0110 6zm-.25 3.25a.75.75 0 00-1.5 0v4.5c0 .414.336.75.75.75h.5a.75.75 0 00.75-.75v-4.5z"
                        clipRule="evenodd"
                      />
                    </svg>
                    <span className="button-text-mobile">Help</span>
                    <span className="button-text-desktop">Manual</span>
                  </button>
                </a>
                <div
                  className="feedback-container"
                  style={{ display: "inline-block", marginLeft: "10px" }}
                >
                  <FeedbackMessage
                    show={exportFeedback}
                    message="Export Started!"
                  />
                </div>
              </div>

              <div className="chapter-filter-group">
                <label htmlFor="chapterFilter">Show:</label>
                <select
                  id="chapterFilter"
                  value={chapterFilter}
                  onChange={(e) => setChapterFilter(e.target.value)}
                  title="Filter Chapters"
                >
                  <option value="all">All Chapters</option>
                  {novel.chapters.map((ch, index) => (
                    <option key={ch.id} value={ch.id}>
                      {ch.title || `Chapter ${index + 1}`}
                    </option>
                  ))}
                </select>
              </div>

              <button
                className="delete-btn delete-novel-btn"
                onClick={() => onDeleteNovel(novel.id)}
                title="Delete This Novel"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  viewBox="0 0 20 20"
                  fill="currentColor"
                  width="16"
                  height="16"
                  style={{ verticalAlign: "middle", marginRight: "4px" }}
                >
                  <path
                    fillRule="evenodd"
                    d="M8.75 1A2.75 2.75 0 0 0 6 3.75v.443c-.795.077-1.58.22-2.326.418C2.675 4.83 2 5.777 2 6.75V17.25A2.75 2.75 0 0 0 4.75 20h10.5A2.75 2.75 0 0 0 18 17.25V6.75c0-.973-.675-1.92-1.674-2.14C15.58 4.413 14.795 4.27 14 4.193v-.443A2.75 2.75 0 0 0 11.25 1h-2.5ZM7.5 3.75c0-.69.56-1.25 1.25-1.25h2.5c.69 0 1.25.56 1.25 1.25v.443c-.795.077-1.58.22-2.326.418C10.42 4.83 10 5.27 10 5.75v.5h-1v-.5c0-.48-.42-.92-.924-1.14-.746-.198-1.531-.341-2.326-.418V3.75ZM8.5 7.5V15h-1V7.5h1Zm3 0V15h-1V7.5h1Z"
                    clipRule="evenodd"
                  />
                </svg>
                <span className="button-text-mobile">Delete</span>
                <span className="button-text-desktop">Delete Novel</span>
              </button>
            </div>
            <hr />
            <div id="chaptersContainer">
              {filteredChapters.length === 0 &&
                chapterFilter !== "all" &&
                novel.chapters.length > 0 && (
                  <p style={{ fontStyle: "italic", color: "#888" }}>
                    Chapter not found or filter mismatch. Select "All Chapters"
                    to see all content.
                  </p>
                )}
              {filteredChapters.length > 0
                ? filteredChapters.map((chapter) => {
                    // Find the original index for correct move button disabling
                    const originalIndex = novel.chapters.findIndex(
                      (ch) => ch.id === chapter.id
                    );
                    // Determine if the summary for THIS chapter is collapsed
                    const isSummaryCollapsed =
                      typeof summaryCollapseStates[chapter.id] !== "undefined"
                        ? summaryCollapseStates[chapter.id]
                        : true; // Default to collapsed

                    return (
                      <Chapter
                        key={chapter.id}
                        novelId={novel.id}
                        chapter={chapter}
                        chapterIndex={originalIndex}
                        totalChapters={novel.chapters.length}
                        onUpdateChapterTitle={onUpdateChapterTitle}
                        onDeleteChapter={onDeleteChapter}
                        onMoveChapter={onMoveChapter}
                        onAddBeat={onAddBeat}
                        onUpdateGeneratedText={onUpdateGeneratedText}
                        onDeleteBeat={onDeleteBeat}
                        onMoveBeat={onMoveBeat}
                        onShowPrompt={onShowPrompt}
                        isSummaryCollapsed={isSummaryCollapsed}
                        onToggleSummaryCollapse={onToggleSummaryCollapse}
                        onUpdateChapterSummary={onUpdateChapterSummary}
                        onCopySummaryPrompt={onCopySummaryPrompt}
                        onEditBeat={onEditBeat}
                        onShowEditGeneratedTextModal={
                          onShowEditGeneratedTextModal
                        }
                      />
                    );
                  })
                : chapterFilter === "all" && (
                    <p>No chapters yet. Click "+ Add New Chapter" below.</p>
                  )}
            </div>
            <button onClick={() => onAddChapter(novel.id)}>
              + Add New Chapter
            </button>
          </div>
        );
      }
      // --- NovelListView Component ---
      function NovelListView({
        novels,
        onCreateNovel,
        onOpenNovel,
        onDeleteNovel,
        onImportNovel,
        user, // Receive user prop
        loading, // Receive loading prop
      }) {
        const [newNovelTitle, setNewNovelTitle] = useState("");
        const [importVisible, setImportVisible] = useState(false);
        const [importText, setImportText] = useState("");

        const handleCreate = () => {
          if (!user) {
            alert("Please log in to create a novel.");
            return;
          }
          onCreateNovel(newNovelTitle);
          setNewNovelTitle(""); // Clear input
        };

        const handleImport = () => {
          if (!user) {
            alert("Please log in to import a novel.");
            return;
          }
          if (!importText.trim()) {
            alert("Please paste the exported novel markdown content first.");
            return;
          }
          onImportNovel(importText);
          setImportText("");
          setImportVisible(false);
        };

        const toggleImport = () => {
          if (!user && !importVisible) {
            // Prevent opening import if logged out
            alert("Please log in to import a novel.");
            return;
          }
          setImportVisible(!importVisible);
          if (importVisible) {
            // If closing
            setImportText("");
          }
        };

        const sortedNovels = useMemo(() => {
          const novelsArray = Array.isArray(novels) ? novels : [];
          return [...novelsArray].sort((a, b) =>
            (a.title || "").localeCompare(b.title || "")
          );
        }, [novels]);

        // Disable inputs/buttons if loading or not logged in
        const isDisabled = loading || !user;

        return (
          <div className="view" id="novelListView">
            <h2>Novels</h2>
            <ul id="novelList">
              {isDisabled && <li>Loading novels...</li>}
              {!isDisabled && sortedNovels.length === 0 && (
                <li>No novels found. Create one below or import one.</li>
              )}
              {!isDisabled &&
                sortedNovels.map((novel) => (
                  <li key={novel.id}>
                    <span
                      className="novel-item-title"
                      onClick={() => onOpenNovel(novel.id)}
                    >
                      {novel.title || "Untitled Novel"}
                    </span>
                    <div>
                      <button onClick={() => onOpenNovel(novel.id)}>
                        Open
                      </button>
                      <button
                        className="delete-btn"
                        onClick={() => onDeleteNovel(novel.id)}
                      >
                        Delete
                      </button>
                    </div>
                  </li>
                ))}
            </ul>
            <div>
              <input
                type="text"
                id="newNovelTitle"
                placeholder="New Novel Title"
                value={newNovelTitle}
                onChange={(e) => setNewNovelTitle(e.target.value)}
                disabled={isDisabled}
              />
              <button onClick={handleCreate} disabled={isDisabled}>
                Create New Novel
              </button>
              <button
                onClick={toggleImport}
                className="import-button"
                disabled={loading}
              >
                {" "}
                {/* Allow toggling import cancel even if logged out */}
                {importVisible ? "Cancel Import" : "Import Novel"}
              </button>
            </div>

            {importVisible && (
              <div className="import-area show">
                <textarea
                  id="importText"
                  placeholder="Paste exported novel markdown here..."
                  value={importText}
                  onChange={(e) => setImportText(e.target.value)}
                  disabled={isDisabled}
                ></textarea>
                <button onClick={handleImport} disabled={isDisabled}>
                  Import
                </button>
                <button className="secondary-btn" onClick={toggleImport}>
                  Cancel
                </button>
              </div>
            )}
            <div
              style={{
                marginTop: "15px",
                fontSize: "0.9em",
                textAlign: "center",
              }}
            >
              <a href="./manual.html" target="_blank" rel="noopener noreferrer">
                Need help? Read the User Manual
              </a>
            </div>
          </div>
        );
      }

      // --- Auth UI Component ---
      function AuthUI({ user, onLogin, onLogout, loading }) {
        if (loading) {
          return <div className="auth-container">Loading user...</div>;
        }

        return (
          <div className="auth-container">
            {user ? (
              <React.Fragment>
                <div className="user-info">
                  <img
                    src={user.photoURL || "placeholder.png"}
                    alt="User profile"
                    referrerPolicy="no-referrer"
                  />
                  <span>Welcome, {user.displayName || user.email}!</span>
                </div>
                <button onClick={onLogout} className="secondary-btn">
                  Logout
                </button>
              </React.Fragment>
            ) : (
              <button onClick={onLogin}>
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  viewBox="0 0 20 20"
                  fill="currentColor"
                  width="16"
                  height="16"
                  style={{ verticalAlign: "middle", marginRight: "5px" }}
                >
                  <path d="M9.99 1.75a8.25 8.25 0 00-5.756 14.214.75.75 0 01-.993-1.126 6.75 6.75 0 1111.498 0 .75.75 0 11-.993 1.126A8.25 8.25 0 009.99 1.75z" />
                  <path d="M12 9.75a.75.75 0 01.75.75v3a.75.75 0 01-1.5 0v-3a.75.75 0 01.75-.75z" />
                  <path
                    fillRule="evenodd"
                    d="M9.99 3.25a.75.75 0 01.75.75v6a.75.75 0 01-1.5 0V4a.75.75 0 01.75-.75z"
                    clipRule="evenodd"
                  />
                </svg>
                Login with Google
              </button>
            )}
          </div>
        );
      }

      // --- Main App Component ---
      function App() {
        const [novels, setNovels] = useState([]);
        const [currentView, setCurrentView] = useState("list"); // 'list' or 'editor'
        const [currentNovelId, setCurrentNovelId] = useState(null);
        const [modalContent, setModalContent] = useState(null); // { type: 'prompt'|'template'|'export'|'editBeat'|'editGeneratedText', data: ... }
        const [summaryCollapseStates, setSummaryCollapseStates] = useState({});
        const [user, setUser] = useState(null); // Firebase user object
        const [loading, setLoading] = useState(true); // Loading state for auth and initial data
        const isSaving = useRef(false); // Ref to track if a save is in progress

        // Check if Firebase was initialized
        if (typeof auth === "undefined" || typeof db === "undefined") {
          // Render an error message if Firebase didn't initialize
          // This was handled in the initial script, but double-check
          return (
            <div className="container">
              <h1>NovelTokenToken</h1>
              <div
                style={{
                  color: "red",
                  padding: "20px",
                  border: "1px solid red",
                  backgroundColor: "#ffebee",
                }}
              >
                <h2>Firebase Connection Error</h2>
                <p>
                  The application could not connect to Firebase. Please ensure
                  the Firebase configuration in the HTML is correct and check
                  the browser console for more details.
                </p>
              </div>
            </div>
          );
        }

        // --- Authentication Listener ---
        useEffect(() => {
          setLoading(true);
          const unsubscribe = auth.onAuthStateChanged(async (firebaseUser) => {
            if (firebaseUser) {
              console.log("User logged in:", firebaseUser.uid);
              setUser(firebaseUser);
              await loadDataFromFirestore(firebaseUser.uid); // Load data after user is set
            } else {
              console.log("User logged out.");
              setUser(null);
              setNovels([]); // Clear data when logged out
              setSummaryCollapseStates({});
              setCurrentView("list"); // Go back to list view on logout
              setCurrentNovelId(null);
              // Optionally clear local storage backup on logout
              // localStorage.removeItem(LS_KEY);
              // localStorage.removeItem(LS_SUMMARY_STATE_KEY);
              setLoading(false); // Finished processing logout
            }
            // setLoading(false) will be called inside loadDataFromFirestore or here if logged out
          });
          return () => unsubscribe(); // Cleanup listener on unmount
        }, []);

        // --- Data Loading from Firestore ---
        const loadDataFromFirestore = async (userId) => {
          if (!userId) {
            setLoading(false); // Ensure loading stops if no userId
            return;
          }
          console.log("Loading data for user:", userId);
          setLoading(true); // Indicate loading data specifically
          const userDocRef = db
            .collection("users")
            .doc(userId)
            .collection("novels")
            .doc("data");
          try {
            const docSnap = await userDocRef.get();
            if (docSnap.exists) {
              const data = docSnap.data();
              const loadedNovels = validateAndCleanNovels(data.novels || []);
              const loadedStates = data.summaryStates || {};

              setNovels(loadedNovels);
              setSummaryCollapseStates(
                typeof loadedStates === "object" && loadedStates !== null
                  ? loadedStates
                  : {}
              );
              console.log("Data loaded from Firestore.");

              // Also update local storage backup after successful Firestore load
              localStorage.setItem(LS_KEY, JSON.stringify(loadedNovels));
              localStorage.setItem(
                LS_SUMMARY_STATE_KEY,
                JSON.stringify(loadedStates)
              );
            } else {
              console.log(
                "No novel data found for user in Firestore. Checking localStorage backup."
              );
              // Attempt to load from localStorage if Firestore is empty
              const storedNovels = localStorage.getItem(LS_KEY);
              const storedStates = localStorage.getItem(LS_SUMMARY_STATE_KEY);
              let localNovels = [];
              let localStates = {};
              if (storedNovels) {
                try {
                  localNovels = validateAndCleanNovels(
                    JSON.parse(storedNovels)
                  );
                } catch (e) {
                  console.error("Error parsing local novels", e);
                }
              }
              if (storedStates) {
                try {
                  const parsedStates = JSON.parse(storedStates);
                  localStates =
                    typeof parsedStates === "object" && parsedStates !== null
                      ? parsedStates
                      : {};
                } catch (e) {
                  console.error("Error parsing local summary states", e);
                }
              }
              setNovels(localNovels);
              setSummaryCollapseStates(localStates);
              if (localNovels.length > 0) {
                console.log("Loaded data from localStorage backup.");
                // Optionally save this back to Firestore immediately
                // await saveDataToFirestore(userId, localNovels, localStates);
              } else {
                console.log("No data in Firestore or localStorage.");
                setNovels([]);
                setSummaryCollapseStates({});
              }
            }
          } catch (error) {
            console.error("Error loading data from Firestore:", error);
            alert(
              "Error loading your data. Please check your connection and try again. Offline data might be shown if available."
            );
            // Fallback to local storage on error
            try {
              const storedNovels = localStorage.getItem(LS_KEY);
              const storedStates = localStorage.getItem(LS_SUMMARY_STATE_KEY);
              setNovels(
                storedNovels
                  ? validateAndCleanNovels(JSON.parse(storedNovels))
                  : []
              );
              const parsedStates = storedStates ? JSON.parse(storedStates) : {};
              setSummaryCollapseStates(
                typeof parsedStates === "object" && parsedStates !== null
                  ? parsedStates
                  : {}
              );
              console.log(
                "Loaded data from localStorage due to Firestore error."
              );
            } catch (e) {
              console.error("Error loading from local storage fallback:", e);
              setNovels([]);
              setSummaryCollapseStates({});
            }
          } finally {
            setLoading(false); // Finished loading/processing
          }
        };

        // --- Data Saving ---
        const saveDataToFirestore = useCallback(
          async (userId, currentNovels, currentSummaryStates) => {
            if (!userId || isSaving.current) {
              console.log("Save skipped: No user or save already in progress.");
              return;
            }
            if (loading) {
              console.log("Save skipped: Initial load in progress.");
              return; // Prevent saving during initial load race condition
            }

            console.log("Attempting to save data for user:", userId);
            isSaving.current = true;
            const userDocRef = db
              .collection("users")
              .doc(userId)
              .collection("novels")
              .doc("data");

            // Prepare clean data (important!)
            // Firestore cannot store undefined values directly.
            // Ensure all properties expected exist, even if null or empty array/string.
            const cleanNovels = JSON.parse(JSON.stringify(currentNovels || [])); // Deep copy and remove undefined
            const cleanSummaryStates = JSON.parse(
              JSON.stringify(currentSummaryStates || {})
            );

            try {
              await userDocRef.set(
                {
                  novels: cleanNovels,
                  summaryStates: cleanSummaryStates,
                },
                { merge: true }
              ); // Use merge:true just in case other fields exist, though unlikely here
              console.log("Data saved successfully to Firestore.");

              // Also save to local storage as a backup
              localStorage.setItem(LS_KEY, JSON.stringify(cleanNovels));
              localStorage.setItem(
                LS_SUMMARY_STATE_KEY,
                JSON.stringify(cleanSummaryStates)
              );
              console.log("Data saved successfully to Local Storage Backup.");
            } catch (error) {
              console.error("Error saving data to Firestore:", error);
              alert(
                "Error saving changes to the cloud. Your latest changes might only be saved locally in this browser session. Please check your connection."
              );
              // Still save to local storage even if Firestore fails
              try {
                localStorage.setItem(LS_KEY, JSON.stringify(cleanNovels));
                localStorage.setItem(
                  LS_SUMMARY_STATE_KEY,
                  JSON.stringify(cleanSummaryStates)
                );
                console.warn(
                  "Data saved to Local Storage Backup due to Firestore error."
                );
              } catch (localError) {
                console.error(
                  "Error saving data to Local Storage Backup:",
                  localError
                );
                alert(
                  "CRITICAL ERROR: Failed to save data to both Firebase and Local Storage. Changes may be lost."
                );
              }
            } finally {
              isSaving.current = false; // Allow next save
            }
          },
          [loading]
        ); // Depend on loading state

        // Debounced save function
        const debouncedSave = useCallback(
          debounce((uid, novelsData, summaryData) => {
            saveDataToFirestore(uid, novelsData, summaryData);
          }, 2000), // Save 2 seconds after the last change
          [saveDataToFirestore] // Recreate debounce if saveDataToFirestore changes
        );

        // Effect to trigger debounced save when data changes and user is logged in
        useEffect(() => {
          // Only save if logged in, not loading, and novels state has actually been initialized
          if (user && !loading) {
            console.log("Data changed, triggering debounced save...");
            debouncedSave(user.uid, novels, summaryCollapseStates);
          }
        }, [user, novels, summaryCollapseStates, loading, debouncedSave]); // Include loading here

        // --- Authentication Actions ---
        const handleLogin = async () => {
          if (loading) return; // Prevent login attempts while loading
          setLoading(true); // Show loading during login process
          try {
            await auth.signInWithPopup(googleProvider);
            // onAuthStateChanged will handle setting user and loading data
          } catch (error) {
            console.error("Google Sign-In Error:", error);
            alert("Failed to sign in with Google: " + error.message);
            setLoading(false); // Stop loading if login fails
          }
        };

        const handleLogout = async () => {
          if (loading) return; // Prevent logout while loading
          setLoading(true); // Show loading during logout process
          try {
            await auth.signOut();
            // onAuthStateChanged handles clearing user/data & setting loading to false
          } catch (error) {
            console.error("Sign Out Error:", error);
            alert("Failed to sign out: " + error.message);
            setLoading(false); // Stop loading if logout fails
          }
        };

        // --- State Update Helper --- (Now less critical as saving is handled by useEffect)
        const updateNovels = (updateFn) => {
          setNovels((prevNovels) => {
            // Ensure prevNovels is an array before applying the update
            const currentNovels = Array.isArray(prevNovels) ? prevNovels : [];
            // Apply the update function provided by the caller
            const updatedNovels = updateFn(currentNovels);
            // Validate the result before setting state (optional but good practice)
            return validateAndCleanNovels(updatedNovels);
          });
        };

        // --- Novel Actions --- (Largely unchanged logic, but rely on `updateNovels`)
        const handleCreateNovel = (title) => {
          if (!user) return; // Should be handled by disabling button, but double-check
          const newNovel = {
            id: generateId(),
            title: title.trim() || "Untitled Novel",
            template: null, // Use null instead of undefined
            chapters: [],
          };
          updateNovels((prev) => [...prev, newNovel]);
          setCurrentNovelId(newNovel.id);
          setCurrentView("editor");
        };
        const handleOpenNovel = (id) => {
          if (!user) return;
          setCurrentNovelId(id);
          setCurrentView("editor");
        };
        const handleDeleteNovel = (id) => {
          if (!user) return;
          const novelToDelete = novels.find((n) => n.id === id);
          if (!novelToDelete) return;
          if (
            confirm(
              `Are you sure you want to delete the novel "${
                novelToDelete.title || "Untitled Novel"
              }"? This action cannot be undone.`
            )
          ) {
            updateNovels((prev) => prev.filter((novel) => novel.id !== id));
            if (currentNovelId === id) {
              setCurrentView("list");
              setCurrentNovelId(null);
            }
            // Clean up summary state for the deleted novel's chapters
            setSummaryCollapseStates((prevStates) => {
              const newStates = { ...prevStates };
              if (Array.isArray(novelToDelete.chapters)) {
                novelToDelete.chapters.forEach((ch) => delete newStates[ch.id]);
              }
              return newStates;
            });
          }
        };
        const handleUpdateNovel = (id, updates) => {
          if (!user) return;
          updateNovels((prev) =>
            prev.map((novel) =>
              novel.id === id ? { ...novel, ...updates } : novel
            )
          );
        };
        const handleBackToList = () => {
          setCurrentView("list");
          setCurrentNovelId(null);
        };

        // --- Chapter Actions --- (Unchanged logic, use `updateNovels`)
        const handleAddChapter = (novelId) => {
          if (!user) return;
          const newChapter = {
            id: generateId(),
            title: "", // Will be set below
            sceneBeats: [],
            summary: "",
          };
          updateNovels((prev) =>
            prev.map((novel) => {
              if (novel.id === novelId) {
                const currentChapters = Array.isArray(novel.chapters)
                  ? novel.chapters
                  : [];
                newChapter.title = `Chapter ${currentChapters.length + 1}`;
                return { ...novel, chapters: [...currentChapters, newChapter] };
              }
              return novel;
            })
          );
          // Optionally expand the new chapter's summary by default
          setSummaryCollapseStates((prev) => ({
            ...prev,
            [newChapter.id]: false,
          }));
        };
        const handleDeleteChapter = (novelId, chapterId) => {
          if (!user) return;
          const novel = novels.find((n) => n.id === novelId);
          const chapter = novel ? findChapeter(novel, chapterId) : null; // Use corrected findChapEter
          if (!novel || !chapter) return;

          if (
            confirm(
              `Are you sure you want to delete "${
                chapter.title || "this chapter"
              }" and all its scene beats?`
            )
          ) {
            updateNovels((prev) =>
              prev.map((n) => {
                if (n.id === novelId) {
                  const currentChapters = Array.isArray(n.chapters)
                    ? n.chapters
                    : [];
                  return {
                    ...n,
                    chapters: currentChapters.filter(
                      (ch) => ch.id !== chapterId
                    ),
                  };
                }
                return n;
              })
            );
            // Clean up summary state
            setSummaryCollapseStates((prevStates) => {
              const newStates = { ...prevStates };
              delete newStates[chapterId];
              return newStates;
            });
          }
        };
        const handleUpdateChapterTitle = (novelId, chapterId, newTitle) => {
          if (!user) return;
          updateNovels((prev) =>
            prev.map((n) => {
              if (n.id === novelId) {
                const currentChapters = Array.isArray(n.chapters)
                  ? n.chapters
                  : [];
                return {
                  ...n,
                  chapters: currentChapters.map((ch) =>
                    ch.id === chapterId
                      ? { ...ch, title: newTitle.trim() || "Untitled Chapter" } // Ensure trim
                      : ch
                  ),
                };
              }
              return n;
            })
          );
        };
        const handleMoveChapter = (novelId, chapterId, direction) => {
          if (!user) return;
          updateNovels((prev) =>
            prev.map((n) => {
              if (n.id === novelId) {
                const currentChapters = Array.isArray(n.chapters)
                  ? n.chapters
                  : [];
                const chapters = [...currentChapters]; // Create mutable copy
                const index = chapters.findIndex((ch) => ch.id === chapterId);
                if (index === -1) return n; // Chapter not found

                const newIndex = index + direction;
                // Check bounds
                if (newIndex < 0 || newIndex >= chapters.length) return n; // Invalid move

                // Swap elements
                [chapters[index], chapters[newIndex]] = [
                  chapters[newIndex],
                  chapters[index],
                ];

                return { ...n, chapters }; // Return novel with updated chapters array
              }
              return n; // Return other novels unchanged
            })
          );
        };

        // --- Scene Beat Actions --- (Unchanged logic, use `updateNovels`)
        const handleAddBeat = (novelId, chapterId, text) => {
          if (!user) return;
          const newBeat = {
            id: generateId(),
            text: text.trim(),
            generatedText: "",
          };
          updateNovels((prev) =>
            prev.map((n) => {
              if (n.id === novelId) {
                const currentChapters = Array.isArray(n.chapters)
                  ? n.chapters
                  : [];
                return {
                  ...n,
                  chapters: currentChapters.map((ch) => {
                    if (ch.id === chapterId) {
                      const currentBeats = Array.isArray(ch.sceneBeats)
                        ? ch.sceneBeats
                        : [];
                      return { ...ch, sceneBeats: [...currentBeats, newBeat] };
                    }
                    return ch;
                  }),
                };
              }
              return n;
            })
          );
        };
        const handleEditBeat = (novelId, chapterId, beatId) => {
          if (!user) return;
          const novel = novels.find((n) => n.id === novelId);
          const chapter = novel ? findChapeter(novel, chapterId) : null;
          const beat = chapter
            ? chapter.sceneBeats.find((b) => b.id === beatId)
            : null;
          if (!beat) return;
          setModalContent({
            type: "editBeat",
            data: { novelId, chapterId, beatId, text: beat.text || "" },
          });
        };
        const handleSaveBeatEdit = (novelId, chapterId, beatId, newText) => {
          if (!user) return;
          handleUpdateBeatText(novelId, chapterId, beatId, newText); // Use the specific update function
          handleCloseModal();
        };
        const handleDeleteBeat = (novelId, chapterId, beatId) => {
          if (!user) return;
          if (confirm("Are you sure you want to delete this scene beat?")) {
            updateNovels((prev) =>
              prev.map((n) => {
                if (n.id === novelId) {
                  const currentChapters = Array.isArray(n.chapters)
                    ? n.chapters
                    : [];
                  return {
                    ...n,
                    chapters: currentChapters.map((ch) => {
                      if (ch.id === chapterId) {
                        const currentBeats = Array.isArray(ch.sceneBeats)
                          ? ch.sceneBeats
                          : [];
                        return {
                          ...ch,
                          sceneBeats: currentBeats.filter(
                            (b) => b.id !== beatId
                          ),
                        };
                      }
                      return ch;
                    }),
                  };
                }
                return n;
              })
            );
          }
        };
        const handleUpdateBeatText = (novelId, chapterId, beatId, newText) => {
          // This function is specifically for updating the instruction text from the modal
          if (!user) return;
          updateNovels((prev) =>
            prev.map((n) => {
              if (n.id === novelId) {
                const currentChapters = Array.isArray(n.chapters)
                  ? n.chapters
                  : [];
                return {
                  ...n,
                  chapters: currentChapters.map((ch) => {
                    if (ch.id === chapterId) {
                      const currentBeats = Array.isArray(ch.sceneBeats)
                        ? ch.sceneBeats
                        : [];
                      return {
                        ...ch,
                        sceneBeats: currentBeats.map((b) =>
                          b.id === beatId ? { ...b, text: newText } : b
                        ),
                      };
                    }
                    return ch;
                  }),
                };
              }
              return n;
            })
          );
        };
        const handleUpdateGeneratedText = (
          novelId,
          chapterId,
          beatId,
          genText
        ) => {
          // This function is specifically for updating the generated text from its edit modal
          if (!user) return;
          updateNovels((prev) =>
            prev.map((n) => {
              if (n.id === novelId) {
                const currentChapters = Array.isArray(n.chapters)
                  ? n.chapters
                  : [];
                return {
                  ...n,
                  chapters: currentChapters.map((ch) => {
                    if (ch.id === chapterId) {
                      const currentBeats = Array.isArray(ch.sceneBeats)
                        ? ch.sceneBeats
                        : [];
                      return {
                        ...ch,
                        sceneBeats: currentBeats.map((b) =>
                          b.id === beatId ? { ...b, generatedText: genText } : b
                        ),
                      };
                    }
                    return ch;
                  }),
                };
              }
              return n;
            })
          );
        };
        const handleMoveBeat = (novelId, chapterId, beatId, direction) => {
          if (!user) return;
          updateNovels((prev) =>
            prev.map((n) => {
              if (n.id === novelId) {
                const currentChapters = Array.isArray(n.chapters)
                  ? n.chapters
                  : [];
                return {
                  ...n,
                  chapters: currentChapters.map((ch) => {
                    if (ch.id === chapterId) {
                      const currentBeats = Array.isArray(ch.sceneBeats)
                        ? ch.sceneBeats
                        : [];
                      const beats = [...currentBeats]; // Mutable copy
                      const index = beats.findIndex((b) => b.id === beatId);
                      if (index === -1) return ch; // Beat not found

                      const newIndex = index + direction;
                      // Check bounds
                      if (newIndex < 0 || newIndex >= beats.length) return ch; // Invalid move

                      // Swap
                      [beats[index], beats[newIndex]] = [
                        beats[newIndex],
                        beats[index],
                      ];
                      return { ...ch, sceneBeats: beats };
                    }
                    return ch;
                  }),
                };
              }
              return n;
            })
          );
        };

        // --- Summary Actions ---
        const handleUpdateChapterSummary = (
          novelId,
          chapterId,
          summaryText
        ) => {
          if (!user) return;
          updateNovels((prev) =>
            prev.map((n) => {
              if (n.id === novelId) {
                const currentChapters = Array.isArray(n.chapters)
                  ? n.chapters
                  : [];
                return {
                  ...n,
                  chapters: currentChapters.map(
                    (ch) =>
                      ch.id === chapterId ? { ...ch, summary: summaryText } : ch // Update summary
                  ),
                };
              }
              return n;
            })
          );
        };
        const handleToggleSummaryCollapse = (chapterId) => {
          // This only affects UI state, doesn't need login check, and saving is handled by the main useEffect
          setSummaryCollapseStates((prevStates) => {
            const currentState =
              typeof prevStates[chapterId] !== "undefined"
                ? prevStates[chapterId]
                : true; // Default collapsed
            return { ...prevStates, [chapterId]: !currentState };
          });
        };

        // --- Prompt Generation --- (Unchanged logic)
        const generatePromptText = (novelId, chapterId, beatId) => {
          const novel = novels.find((n) => n.id === novelId);
          if (!novel || !Array.isArray(novel.chapters))
            return { error: "Novel or chapters not found/invalid" };
          const chapterIndex = novel.chapters.findIndex(
            (ch) => ch.id === chapterId
          );
          const chapter = novel.chapters[chapterIndex];
          if (
            chapterIndex === -1 ||
            !chapter ||
            !Array.isArray(chapter.sceneBeats)
          )
            // Check chapterIndex too
            return { error: "Chapter or scene beats not found/invalid" };
          const beatIndex = chapter.sceneBeats.findIndex(
            (b) => b.id === beatId
          );
          const beat = chapter.sceneBeats[beatIndex];
          if (beatIndex === -1 || !beat)
            return { error: "Scene beat not found" };

          let storySoFar = "";
          const maxContextLength = 10000;

          // Previous chapters context
          for (let i = 0; i < chapterIndex; i++) {
            const prevChapter = novel.chapters[i];
            if (!prevChapter || !Array.isArray(prevChapter.sceneBeats))
              continue;
            let chapterContext = "";
            if (prevChapter.summary) {
              chapterContext = `Summary of Chapter ${i + 1}: ${
                prevChapter.title || "Untitled"
              }\n${prevChapter.summary}\n\n`;
            } else {
              const prevChapterText = prevChapter.sceneBeats
                .map((b) => b.generatedText || "")
                .filter(Boolean)
                .join("\n\n");
              if (prevChapterText) {
                chapterContext = `Content from Chapter ${i + 1}: ${
                  prevChapter.title || "Untitled"
                }\n${prevChapterText}\n\n`;
              }
            }
            if (
              storySoFar.length + chapterContext.length <
              maxContextLength * 1.2
            ) {
              // Allow slightly over before check
              storySoFar += chapterContext;
            } else break; // Stop adding chapters
          }

          // Previous beats in current chapter
          for (let i = 0; i < beatIndex; i++) {
            const prevBeat = chapter.sceneBeats[i];
            if (prevBeat && prevBeat.generatedText) {
              const beatText = prevBeat.generatedText + "\n\n";
              if (
                storySoFar.length + beatText.length <
                maxContextLength * 1.2
              ) {
                storySoFar += beatText;
              } else break; // Stop adding beats
            }
          }

          // Truncate if needed
          if (storySoFar.length > maxContextLength) {
            const excess = storySoFar.length - maxContextLength;
            storySoFar =
              `... (trimmed ${excess} characters from the beginning)\n` +
              storySoFar.slice(excess);
          }
          storySoFar = storySoFar.trim();

          const template = getEffectiveTemplate(novel);
          const instructionsText = beat.text || "";
          let prompt = template.replace(
            "{storySoFar}",
            storySoFar || "This is the beginning of the story."
          );
          prompt = prompt.replace("{instructions}", instructionsText);
          return { prompt: prompt.trim() };
        };

        // --- Modal Handling --- (Unchanged logic)
        const handleShowPrompt = (novelId, chapterId, beatId) => {
          if (!user) {
            alert("Please log in first.");
            return;
          }
          const { prompt, error } = generatePromptText(
            novelId,
            chapterId,
            beatId
          );
          if (error) {
            alert(`Error generating prompt: ${error}`);
            return;
          }
          setModalContent({ type: "prompt", data: { text: prompt } });
        };
        const handleShowTemplateEditor = (novelId) => {
          if (!user) {
            alert("Please log in first.");
            return;
          }
          const novel = novels.find((n) => n.id === novelId);
          if (!novel) return;
          setModalContent({
            type: "template",
            data: {
              novelId: novel.id,
              currentTemplate: getEffectiveTemplate(novel),
            },
          });
        };
        const handleShowExportModal = (exportText) => {
          if (!user) {
            alert("Please log in first.");
            return;
          }
          setModalContent({ type: "export", data: { text: exportText } });
        };
        const handleShowEditGeneratedTextModal = (
          novelId,
          chapterId,
          beatId,
          generatedText
        ) => {
          if (!user) {
            alert("Please log in first.");
            return;
          }
          setModalContent({
            type: "editGeneratedText",
            data: {
              novelId,
              chapterId,
              beatId,
              generatedText: generatedText || "",
            },
          });
        };
        const handleCloseModal = () => {
          setModalContent(null);
        };
        const handleSaveTemplate = (novelId, newTemplate) => {
          if (!user) return;
          const templateToSave =
            newTemplate.trim() !== DEFAULT_PROMPT_TEMPLATE.trim()
              ? newTemplate.trim() // Save trimmed version
              : null; // Store null if it's same as default
          handleUpdateNovel(novelId, { template: templateToSave });
          handleCloseModal();
        };
        const handleSaveGeneratedText = (
          novelId,
          chapterId,
          beatId,
          newText
        ) => {
          if (!user) return;
          handleUpdateGeneratedText(novelId, chapterId, beatId, newText); // Use specific update function
          handleCloseModal();
        };

        // --- Copy Actions --- (Unchanged logic)
        const handleCopyPromptFromModal = (text) => {
          return copyToClipboard(text);
        };
        const handleCopySummaryPrompt = (novelId, chapterId) => {
          if (!user) {
            alert("Please log in first.");
            return Promise.reject(new Error("Not logged in"));
          }
          const novel = novels.find((n) => n.id === novelId);
          const chapter = novel ? findChapeter(novel, chapterId) : null;
          if (!chapter || !Array.isArray(chapter.sceneBeats))
            return Promise.reject(
              new Error("Chapter or scene beats not found/invalid")
            );

          const chapterText = chapter.sceneBeats
            .map((beat) => beat.generatedText || "")
            .filter(Boolean)
            .join("\n\n");

          if (!chapterText) {
            alert("No generated content in this chapter to summarize.");
            return Promise.reject(new Error("No content to summarize"));
          }
          const prompt = `Please write a concise summary of the following chapter content:\n\n${chapterText}`;
          return copyToClipboard(prompt);
        };

        // --- Import / Export --- (Unchanged logic, checks added to handlers)
        const handleExportNovel = (novelId) => {
          return new Promise((resolve, reject) => {
            if (!user) return reject(new Error("Please log in to export."));
            const novel = novels.find((n) => n.id === novelId);
            if (!novel) return reject(new Error("Novel not found"));

            let markdown = `# ${novel.title || "Untitled Novel"}\n\n`;
            // Include template only if it's custom (not null and not default)
            const effectiveTemplate = getEffectiveTemplate(novel);
            if (effectiveTemplate !== DEFAULT_PROMPT_TEMPLATE) {
              markdown += `### Template\n\n\`\`\`\n${effectiveTemplate}\n\`\`\`\n\n`;
            }

            const currentChapters = Array.isArray(novel.chapters)
              ? novel.chapters
              : [];
            currentChapters.forEach((chapter, chapterIndex) => {
              markdown += `## ${
                chapter.title || `Chapter ${chapterIndex + 1}`
              }\n\n`;
              if (chapter.summary) {
                markdown += `### Summary\n\n${chapter.summary}\n\n`;
              }
              markdown += `### Scene Beats\n\n`;
              const currentBeats = Array.isArray(chapter.sceneBeats)
                ? chapter.sceneBeats
                : [];
              currentBeats.forEach((beat, beatIndex) => {
                markdown += `#### Beat ${beatIndex + 1}\n\n`;
                markdown += `**Scene Description:**\n\n${beat.text || ""}\n\n`; // Added newline for clarity
                markdown += `**Generated Content:**\n\n${
                  beat.generatedText || ""
                }\n\n`; // Added newline
              });
            });
            handleShowExportModal(markdown.trim());
            resolve();
          });
        };
        const handleImportNovel = (text) => {
          if (!user) {
            alert("Please log in to import.");
            return;
          }
          try {
            const novel = {
              id: generateId(),
              title: "Imported Novel",
              template: null, // Default to null initially
              chapters: [],
            };
            const lines = text.split("\n");
            let currentChapter = null;
            let currentBeat = null;
            let readingMode = null; // null | 'template' | 'summary' | 'description' | 'generated'
            let accumulatingText = "";

            const finishAccumulatingText = () => {
              const content = accumulatingText.trim();
              if (readingMode === "template") {
                // Store template only if it's not the default
                novel.template =
                  content && content !== DEFAULT_PROMPT_TEMPLATE.trim()
                    ? content
                    : null;
              } else if (readingMode === "summary" && currentChapter) {
                currentChapter.summary = content;
              } else if (readingMode === "description" && currentBeat) {
                currentBeat.text = content;
              } else if (readingMode === "generated" && currentBeat) {
                currentBeat.generatedText = content;
              }
              accumulatingText = "";
            };

            lines.forEach((line) => {
              const trimmedLine = line.trim();

              if (trimmedLine.startsWith("# ")) {
                finishAccumulatingText();
                novel.title =
                  trimmedLine.substring(2).trim() || "Imported Novel";
                readingMode = null;
              } else if (trimmedLine.startsWith("## ")) {
                finishAccumulatingText();
                currentChapter = {
                  id: generateId(),
                  title: trimmedLine.substring(3).trim(),
                  summary: "",
                  sceneBeats: [],
                };
                novel.chapters.push(currentChapter);
                currentBeat = null;
                readingMode = null;
              } else if (trimmedLine === "### Template") {
                finishAccumulatingText();
                readingMode = "template";
              } else if (trimmedLine === "### Summary" && currentChapter) {
                finishAccumulatingText();
                readingMode = "summary";
              } else if (trimmedLine === "### Scene Beats" && currentChapter) {
                finishAccumulatingText();
                readingMode = null; // Section header, reset mode
              } else if (
                trimmedLine.startsWith("#### Beat") &&
                currentChapter
              ) {
                finishAccumulatingText();
                currentBeat = { id: generateId(), text: "", generatedText: "" };
                currentChapter.sceneBeats.push(currentBeat);
                readingMode = null;
              } else if (
                trimmedLine === "**Scene Description:**" &&
                currentBeat
              ) {
                finishAccumulatingText();
                readingMode = "description";
              } else if (
                trimmedLine === "**Generated Content:**" &&
                currentBeat
              ) {
                finishAccumulatingText();
                readingMode = "generated";
              } else if (readingMode === "template" && trimmedLine === "```") {
                // End of template block, handled by finishAccumulatingText called by next header
              } else if (readingMode) {
                // Accumulate lines if in a reading mode
                accumulatingText += line + "\n";
              } else {
                // Ignore lines outside known sections unless it looks like part of a previous block
                if (accumulatingText && line) {
                  accumulatingText += line + "\n";
                }
              }
            });
            finishAccumulatingText(); // Process any remaining text

            if (!novel.title || novel.chapters.length === 0) {
              console.warn(
                "Imported text might be incomplete or invalid format."
              );
            }
            // Validate imported structure
            const validatedNovel = validateAndCleanNovels([novel])[0]; // Validate the single imported novel

            updateNovels((prev) => [...prev, validatedNovel]); // Add the validated novel
            alert(`Novel "${validatedNovel.title}" imported successfully!`);
          } catch (e) {
            console.error("Import error:", e);
            alert(
              "Error importing novel. Please check the format and console for details.\n\n" +
                e.message
            );
          }
        };

        // --- Generate clean novel text --- (Unchanged logic)
        const generateNovelText = (novelId) => {
          return new Promise((resolve, reject) => {
            if (!user) return reject(new Error("Please log in to view text."));
            const novel = novels.find((n) => n.id === novelId);
            if (!novel) return reject(new Error("Novel not found"));

            let novelText = `${novel.title || "Untitled Novel"}\n\n`;
            const currentChapters = Array.isArray(novel.chapters)
              ? novel.chapters
              : [];

            currentChapters.forEach((chapter, chapterIndex) => {
              novelText += `${
                chapter.title || `Chapter ${chapterIndex + 1}`
              }\n\n`;
              const currentBeats = Array.isArray(chapter.sceneBeats)
                ? chapter.sceneBeats
                : [];
              const chapterContent = currentBeats
                .map((beat) => beat.generatedText || "")
                .filter(Boolean) // Remove empty strings
                .join("\n\n"); // Join with double newline

              novelText += `${chapterContent.trim()}\n\n`; // Trim content before adding final newlines
            });

            resolve(novelText.trim()); // Trim final result
          });
        };
        const handleViewNovelText = (novelId) => {
          if (!user) {
            alert("Please log in first.");
            return;
          }
          generateNovelText(novelId)
            .then((novelText) => {
              setModalContent({ type: "novelText", data: { text: novelText } });
            })
            .catch((err) => {
              console.error("Error generating novel text:", err);
              alert("Error generating novel text. See console for details.");
            });
        };

        // --- Current Novel Data ---
        const currentNovel = useMemo(() => {
          if (!user || !Array.isArray(novels)) return null; // Need user and valid novels array
          return novels.find((n) => n.id === currentNovelId) || null;
        }, [novels, currentNovelId, user]); // Depend on user as well

        // --- Render Logic ---
        return (
          <div className="container">
            <AuthUI
              user={user}
              onLogin={handleLogin}
              onLogout={handleLogout}
              loading={loading}
            />

            <h1>NovelTokenToken</h1>

            {loading && <div className="loading-indicator">Loading...</div>}

            {!loading && !user && (
              <div className="login-prompt">
                <p>
                  Please log in with your Google account to manage your novels.
                </p>
                <button onClick={handleLogin}>
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 20 20"
                    fill="currentColor"
                    width="16"
                    height="16"
                    style={{ verticalAlign: "middle", marginRight: "5px" }}
                  >
                    <path d="M9.99 1.75a8.25 8.25 0 00-5.756 14.214.75.75 0 01-.993-1.126 6.75 6.75 0 1111.498 0 .75.75 0 11-.993 1.126A8.25 8.25 0 009.99 1.75z" />
                    <path d="M12 9.75a.75.75 0 01.75.75v3a.75.75 0 01-1.5 0v-3a.75.75 0 01.75-.75z" />
                    <path
                      fillRule="evenodd"
                      d="M9.99 3.25a.75.75 0 01.75.75v6a.75.75 0 01-1.5 0V4a.75.75 0 01.75-.75z"
                      clipRule="evenodd"
                    />
                  </svg>
                  Login with Google
                </button>
              </div>
            )}

            {!loading && user && currentView === "list" && (
              <NovelListView
                novels={novels}
                onCreateNovel={handleCreateNovel}
                onOpenNovel={handleOpenNovel}
                onDeleteNovel={handleDeleteNovel}
                onImportNovel={handleImportNovel}
                user={user}
                loading={loading}
              />
            )}

            {!loading && user && currentView === "editor" && currentNovel && (
              <NovelEditorView
                novel={currentNovel}
                onBack={handleBackToList}
                onUpdateNovel={handleUpdateNovel}
                onDeleteNovel={handleDeleteNovel}
                onAddChapter={handleAddChapter}
                onDeleteChapter={handleDeleteChapter}
                onMoveChapter={handleMoveChapter}
                onUpdateChapterTitle={handleUpdateChapterTitle}
                onAddBeat={handleAddBeat}
                onDeleteBeat={handleDeleteBeat}
                onMoveBeat={handleMoveBeat}
                onUpdateBeatText={handleUpdateBeatText} // Pass down for edit modal
                onUpdateGeneratedText={handleUpdateGeneratedText} // Pass down for edit modal
                onUpdateChapterSummary={handleUpdateChapterSummary}
                onExportNovel={handleExportNovel}
                onShowPrompt={handleShowPrompt}
                onShowTemplateEditor={handleShowTemplateEditor}
                summaryCollapseStates={summaryCollapseStates} // Pass down
                onToggleSummaryCollapse={handleToggleSummaryCollapse}
                onCopySummaryPrompt={handleCopySummaryPrompt}
                onEditBeat={handleEditBeat} // Pass down
                onShowEditGeneratedTextModal={handleShowEditGeneratedTextModal} // Pass down
                handleViewNovelText={handleViewNovelText} // Pass down
              />
            )}
            {!loading && user && currentView === "editor" && !currentNovel && (
              // Handle case where editor is shown but novel ID is invalid
              <div className="view">
                <p>Novel not found or invalid ID.</p>
                <button onClick={handleBackToList}>Back to List</button>
              </div>
            )}

            {/* --- Modals --- (Render conditionally based on modalContent) */}
            {modalContent && modalContent.type === "prompt" && (
              <PromptModal
                promptText={modalContent.data.text}
                onClose={handleCloseModal}
                onCopy={handleCopyPromptFromModal}
              />
            )}
            {modalContent && modalContent.type === "template" && (
              <TemplateEditorModal
                novelId={modalContent.data.novelId}
                currentTemplate={modalContent.data.currentTemplate}
                onClose={handleCloseModal}
                onSave={handleSaveTemplate}
                defaultTemplate={DEFAULT_PROMPT_TEMPLATE}
              />
            )}
            {modalContent && modalContent.type === "export" && (
              <ExportModal
                exportText={modalContent.data.text}
                onClose={handleCloseModal}
                onCopy={handleCopyPromptFromModal}
              />
            )}
            {modalContent && modalContent.type === "editBeat" && (
              <EditBeatModal
                beatText={modalContent.data.text}
                onClose={handleCloseModal}
                onSave={(editedText) =>
                  handleSaveBeatEdit(
                    modalContent.data.novelId,
                    modalContent.data.chapterId,
                    modalContent.data.beatId,
                    editedText
                  )
                }
              />
            )}
            {modalContent && modalContent.type === "editGeneratedText" && (
              <EditGeneratedTextModal
                generatedText={modalContent.data.generatedText}
                onClose={handleCloseModal}
                onSave={(editedText) =>
                  handleSaveGeneratedText(
                    modalContent.data.novelId,
                    modalContent.data.chapterId,
                    modalContent.data.beatId,
                    editedText
                  )
                }
              />
            )}
            {modalContent && modalContent.type === "novelText" && (
              <NovelTextModal
                novelText={modalContent.data.text}
                onClose={handleCloseModal}
                onCopy={handleCopyPromptFromModal}
              />
            )}
          </div>
        );
      }

      // --- Modal Components (Existing, Unchanged) ---
      function PromptModal({ promptText, onClose, onCopy }) {
        const [copyFeedback, setCopyFeedback] = useState("");
        const handleCopy = () => {
          onCopy(promptText)
            .then(() => {
              setCopyFeedback("Copied!");
              setTimeout(() => setCopyFeedback(""), 1500);
            })
            .catch((err) => {
              console.error("Copy failed:", err);
              setCopyFeedback("Error");
              setTimeout(() => setCopyFeedback(""), 1500);
            });
        };
        return (
          <Modal
            title="Scene Beat Prompt"
            onClose={onClose}
            footer={
              <React.Fragment>
                <button onClick={handleCopy} disabled={!!copyFeedback}>
                  {copyFeedback || "Copy to Clipboard"}
                </button>
                <button className="secondary-btn" onClick={onClose}>
                  Close
                </button>
              </React.Fragment>
            }
          >
            <textarea
              className="prompt-textarea"
              value={promptText || ""}
              readOnly
            />
          </Modal>
        );
      }

      function TemplateEditorModal({
        novelId,
        currentTemplate,
        onClose,
        onSave,
        defaultTemplate,
      }) {
        const [templateText, setTemplateText] = useState(currentTemplate || "");
        useEffect(() => {
          // Update local state if the prop changes (e.g., opening modal for different novel)
          setTemplateText(currentTemplate || "");
        }, [currentTemplate]);

        const handleSave = () => {
          onSave(novelId, templateText);
        };
        const handleReset = () => {
          if (
            confirm(
              "Are you sure you want to reset the template in the editor to the default? This won't save until you click 'Save Template'."
            )
          ) {
            setTemplateText(defaultTemplate);
          }
        };
        return (
          <Modal
            title="Edit Continue Prompt Template"
            onClose={onClose}
            footer={
              <React.Fragment>
                <button onClick={handleSave}>Save Template</button>
                <button className="secondary-btn" onClick={handleReset}>
                  Reset to Default
                </button>
                <button className="secondary-btn" onClick={onClose}>
                  Close
                </button>
              </React.Fragment>
            }
          >
            <textarea
              id="templateTextarea"
              className="prompt-textarea"
              value={templateText}
              onChange={(e) => setTemplateText(e.target.value)}
            />
            <div className="template-help">
              <p>Use these placeholders:</p>
              <ul>
                <li>
                  <code>{"{storySoFar}"}</code> - Context from previous
                  chapters/beats.
                </li>
                <li>
                  <code>{"{instructions}"}</code> - The text from the current
                  scene beat description.
                </li>
              </ul>
            </div>
          </Modal>
        );
      }

      function ExportModal({ exportText, onClose, onCopy }) {
        const [copyFeedback, setCopyFeedback] = useState(false);
        const handleCopy = () => {
          onCopy(exportText)
            .then(() => {
              setCopyFeedback(true);
              setTimeout(() => setCopyFeedback(false), 1500);
            })
            .catch((err) => {
              console.error("Copy failed:", err);
              alert("Failed to copy. See console for details.");
            });
        };
        return (
          <Modal
            title="Export Preview"
            onClose={onClose}
            footer={
              <React.Fragment>
                <button onClick={handleCopy} disabled={copyFeedback}>
                  {copyFeedback ? "Copied!" : "Copy to Clipboard"}
                </button>
                <button className="secondary-btn" onClick={onClose}>
                  Close
                </button>
              </React.Fragment>
            }
          >
            <textarea
              className="prompt-textarea"
              value={exportText || ""}
              readOnly
            />
          </Modal>
        );
      }

      function EditBeatModal({ beatText, onClose, onSave }) {
        const [editedText, setEditedText] = useState(beatText || "");
        const handleSaveClick = () => {
          onSave(editedText); // Call the passed onSave function
        };
        return (
          <Modal
            title="Edit Scene Beat Instruction"
            onClose={onClose}
            footer={
              <React.Fragment>
                <button onClick={handleSaveClick}>Save Changes</button>
                <button className="secondary-btn" onClick={onClose}>
                  Cancel
                </button>
              </React.Fragment>
            }
          >
            <textarea
              className="prompt-textarea"
              value={editedText}
              onChange={(e) => setEditedText(e.target.value)}
              placeholder="Enter scene beat instruction..."
              autoFocus
            />
          </Modal>
        );
      }

      function EditGeneratedTextModal({ generatedText, onClose, onSave }) {
        const [editedText, setEditedText] = useState(generatedText || "");
        const handleSaveClick = () => {
          onSave(editedText); // Call the passed onSave function
        };

        return (
          <Modal
            title="Edit Generated Content"
            onClose={onClose}
            footer={
              <React.Fragment>
                <button onClick={handleSaveClick}>Save Changes</button>
                <button className="secondary-btn" onClick={onClose}>
                  Cancel
                </button>
              </React.Fragment>
            }
          >
            <textarea
              className="prompt-textarea"
              value={editedText}
              onChange={(e) => setEditedText(e.target.value)}
              placeholder="Edit the generated content..."
              autoFocus
            />
          </Modal>
        );
      }

      function NovelTextModal({ novelText, onClose, onCopy }) {
        const [copyFeedback, setCopyFeedback] = useState(false);

        const handleCopy = () => {
          onCopy(novelText)
            .then(() => {
              setCopyFeedback(true);
              setTimeout(() => setCopyFeedback(false), 1500);
            })
            .catch((err) => {
              console.error("Copy failed:", err);
              alert("Failed to copy. See console for details.");
            });
        };

        return (
          <Modal
            title="Novel Text"
            onClose={onClose}
            footer={
              <React.Fragment>
                <button onClick={handleCopy} disabled={copyFeedback}>
                  {copyFeedback ? "Copied!" : "Copy to Clipboard"}
                </button>
                <button className="secondary-btn" onClick={onClose}>
                  Close
                </button>
              </React.Fragment>
            }
          >
            {/* Make modal body scrollable, not just the inner div */}
            <div className="novel-text-modal-body">
              <div className="novel-text-display">
                {novelText || "No content available"}
              </div>
            </div>
          </Modal>
        );
      }

      // --- Render the App ---
      const rootElement = document.getElementById("root");
      if (rootElement) {
        const root = ReactDOM.createRoot(rootElement);
        root.render(<App />);
      } else {
        console.error("Root element (#root) not found in the DOM.");
      }
    </script>
  </body>
</html>

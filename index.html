<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI-Assisted Novel Editor</title>
    <style>
      /* --- Existing styles --- */
      body {
        font-family: sans-serif;
        line-height: 1.6;
        margin: 20px;
        background-color: #f4f4f4;
        color: #333;
      }

      h1,
      h2,
      h3 {
        color: #333;
      }

      button {
        padding: 8px 12px;
        margin: 5px 2px;
        cursor: pointer;
        background-color: #5c67f2;
        color: white;
        border: none;
        border-radius: 4px;
      }

      button:hover {
        background-color: #4a54e1;
      }

      button.delete-btn {
        background-color: #e74c3c;
      }
      button.delete-btn:hover {
        background-color: #c0392b;
      }

      button.move-btn {
        background-color: #f39c12;
        font-weight: bold;
        padding: 4px 8px;
        min-width: 30px;
      }
      button.move-btn:hover {
        background-color: #e67e22;
      }
      button:disabled {
        background-color: #ccc;
        cursor: not-allowed;
      }

      button.secondary-btn {
        background-color: #7f8c8d;
      }
      button.secondary-btn:hover {
        background-color: #6c7a7b;
      }

      .container {
        max-width: 900px;
        margin: auto;
        background: white;
        padding: 20px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        border-radius: 8px;
      }

      #novelListView,
      #novelEditorView,
      #settingsView {
        margin-top: 20px;
      }

      #novelList {
        list-style: none;
        padding: 0;
      }

      #novelList li {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
        border-bottom: 1px solid #eee;
      }
      #novelList li:last-child {
        border-bottom: none;
      }

      .novel-item-title {
        font-weight: bold;
        cursor: pointer;
      }
      .novel-item-title:hover {
        color: #5c67f2;
      }

      .chapter {
        border: 1px solid #ccc;
        border-radius: 5px;
        padding: 15px;
        margin-bottom: 20px;
        background-color: #fff;
      }

      .chapter-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        flex-wrap: wrap; /* Allow wrapping on smaller screens */
      }

      .chapter-title {
        font-size: 1.2em;
        font-weight: bold;
        border: none;
        padding: 5px;
        flex-grow: 1; /* Allow title to take available space */
        margin-right: 10px; /* Space between title and buttons */
      }
      .chapter-title:focus {
        outline: 1px solid #5c67f2;
        background-color: #f0f0ff;
      }

      .chapter-controls button,
      .beat-controls button {
        margin-left: 5px;
      }

      .scene-beat {
        border: 1px dashed #ddd;
        padding: 10px;
        margin-top: 10px;
        background-color: #f9f9f9;
        border-radius: 4px;
      }

      textarea {
        width: 98%;
        min-height: 60px;
        margin-top: 5px;
        margin-bottom: 5px;
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-family: inherit;
        font-size: 1em;
        resize: vertical; /* Allow vertical resize */
        box-sizing: border-box; /* Include padding and border in the element's total width and height */
      }

      .beat-text-area {
        min-height: 40px;
      }

      .generated-text-area,
      .summary-text-area {
        min-height: 80px;
        background-color: #e8f0fe; /* Light blue background for generated content */
      }

      .beat-controls {
        display: flex;
        justify-content: flex-end;
        align-items: center;
        margin-top: 5px;
        flex-wrap: wrap;
      }

      .add-beat-area {
        margin-top: 15px;
        display: flex;
        align-items: center;
      }

      .add-beat-area textarea {
        flex-grow: 1;
        margin-right: 10px;
        min-height: 30px;
      }

      .feedback {
        color: green;
        font-size: 0.9em;
        margin-left: 10px;
        display: inline-block;
        opacity: 0;
        transition: opacity 0.5s ease-out;
      }
      .feedback.show {
        opacity: 1;
      }

      input[type="text"] {
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
      }

      .import-export-area {
        margin: 10px 0;
        padding: 10px;
        background: #f8f8f8;
        border-radius: 4px;
      }

      .import-area {
        display: none;
        margin-top: 10px;
      }

      .import-area.show {
        display: block;
      }

      .import-area textarea {
        width: 100%;
        min-height: 200px;
        margin: 10px 0;
      }

      /* --- New styles for Settings --- */
      #settingsView {
        border: 1px solid #ddd;
        padding: 20px;
        background-color: #f9f9f9;
        border-radius: 5px;
      }
      #promptTemplateTextarea {
        width: 98%;
        min-height: 250px; /* Make it taller for template editing */
        font-family: monospace; /* Often better for template editing */
        font-size: 0.9em;
      }
      .template-help {
        font-size: 0.9em;
        color: #555;
        margin-bottom: 10px;
      }
      .template-help code {
        background-color: #eee;
        padding: 2px 4px;
        border-radius: 3px;
      }

      /* --- Modal Dialog Styles --- */
      .modal-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 1000;
        justify-content: center;
        align-items: center;
      }

      .modal-dialog {
        background-color: white;
        max-width: 80%;
        width: 800px;
        max-height: 80vh;
        border-radius: 8px;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
        display: flex;
        flex-direction: column;
      }

      .modal-header {
        padding: 15px;
        border-bottom: 1px solid #eee;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .modal-title {
        font-size: 1.2em;
        font-weight: bold;
        margin: 0;
      }

      .modal-close {
        background: none;
        border: none;
        font-size: 1.5em;
        cursor: pointer;
        color: #777;
        padding: 0;
        margin: 0;
      }

      .modal-body {
        padding: 15px;
        overflow-y: auto;
        flex-grow: 1;
      }

      .modal-footer {
        padding: 15px;
        border-top: 1px solid #eee;
        display: flex;
        justify-content: flex-end;
      }

      .prompt-textarea {
        width: 100%;
        min-height: 300px;
        font-family: monospace;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        margin-bottom: 10px;
        resize: vertical;
      }

      /* --- New styles for collapsible summary --- */
      .summary-section {
        transition: max-height 0.3s ease-out;
        overflow: hidden;
      }

      .summary-section.collapsed {
        max-height: 0;
      }

      .summary-header {
        display: flex;
        align-items: start;
        cursor: pointer;
      }

      .summary-header h4 {
        margin: 0;
      }

      .collapse-indicator {
        font-size: 18px;
        transition: transform 0.3s;
      }

      .collapsed .collapse-indicator {
        transform: rotate(-90deg);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>AI-Assisted Novel Editor</h1>

      <!-- Novel List View -->
      <div id="novelListView">
        <h2>Novels</h2>
        <ul id="novelList">
          <!-- Novel list items will be injected here -->
        </ul>
        <div>
          <input type="text" id="newNovelTitle" placeholder="New Novel Title" />
          <button onclick="createNovel()">Create New Novel</button>
          <button onclick="toggleImportArea()">Import Novel</button>
          <button class="secondary-btn" onclick="showSettings()">
            ⚙️ Settings
          </button>
          <!-- Settings Button -->
        </div>
        <div class="import-area">
          <textarea
            id="importText"
            placeholder="Paste exported novel here..."
          ></textarea>
          <button onclick="importNovel()">Import</button>
          <button onclick="toggleImportArea()">Cancel</button>
        </div>
      </div>

      <!-- Novel Editor View -->
      <div id="novelEditorView" style="display: none">
        <button onclick="showNovelList()">← Back to Novel List</button>
        <div class="novel-title-edit">
          <input
            type="text"
            id="editNovelTitle"
            oninput="updateNovelTitle(this.value)"
          />
        </div>
        <div class="import-export-area">
          <button onclick="exportNovel(this)">Export Novel</button>
          <span class="feedback">Copied!</span>
        </div>
        <div class="chapter-filter">
          <label for="chapterFilter">Show chapter: </label>
          <select id="chapterFilter" onchange="filterChapters(this.value)">
            <option value="all">All Chapters</option>
            <!-- Chapter options will be injected here -->
          </select>
        </div>
        <button class="delete-btn" onclick="deleteCurrentNovel()">
          Delete This Novel
        </button>
        <hr />

        <div id="chaptersContainer">
          <!-- Chapters will be injected here -->
        </div>

        <button onclick="addChapter()">+ Add New Chapter</button>
      </div>

      <!-- Settings View -->
      <div id="settingsView" style="display: none">
        <button onclick="hideSettings()">← Back to Novel List</button>
        <h2>Settings</h2>
        <h3>Continue Prompt Template</h3>
        <div class="template-help">
          Edit the template used for the "Copy Continue Prompt" button. Use the
          following placeholders:
          <ul>
            <li>
              <code>{storySoFar}</code>: Automatically replaced with summaries
              of previous chapters and the text of previous beats in the current
              chapter.
            </li>
            <li>
              <code>{instructions}</code>: Automatically replaced with the text
              of the current scene beat.
            </li>
          </ul>
        </div>
        <textarea id="promptTemplateTextarea"></textarea>
        <div>
          <button onclick="saveTemplateSettings()">Save Template</button>
          <button class="secondary-btn" onclick="resetTemplateToDefault()">
            Reset to Default
          </button>
          <span class="feedback" id="settingsFeedback">Saved!</span>
        </div>
      </div>

      <!-- Prompt Modal Dialog -->
      <div class="modal-overlay" id="promptModal">
        <div class="modal-dialog">
          <div class="modal-header">
            <h3 class="modal-title">Scene Beat Prompt</h3>
            <button class="modal-close" onclick="closePromptModal()">
              &times;
            </button>
          </div>
          <div class="modal-body">
            <textarea
              id="promptTextarea"
              class="prompt-textarea"
              readonly
            ></textarea>
          </div>
          <div class="modal-footer">
            <button onclick="copyPromptFromModal()">Copy to Clipboard</button>
            <button class="secondary-btn" onclick="closePromptModal()">
              Close
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      const LS_KEY = "novels";
      const LS_TEMPLATE_KEY = "promptTemplate"; // Key for storing the template
      let novels = [];
      let currentNovelId = null;

      // --- Default Prompt Template ---
      const DEFAULT_PROMPT_TEMPLATE = `The story so far:
{storySoFar}

You are an expert fiction writer. Continue the story and write about 400 words for the following instructions:
{instructions}

NEVER conclude the scene on your own, follow the beat instructions very closely. NEVER end with foreshadowing. NEVER write further than what I prompt you with. AVOID imagining possible endings, NEVER deviate from the instructions.

STOP EARLY if the continuation contains what was required in the instructions. You do not need to fill out the full amount of words possible.

- Do not use bold or italic font.
- Do not use expressions like "mechanical precision," "with rapid efficiency," or "at a steady pace", "her stride controlled, efficient", "this is not ideal".
- CT32F, from whose perspective the story is told, cannot feel or detect emotions in others. She cannot feel pain. She cannot assess things like beauty, nor does she feel the wind or cold.
- Do not measure parameters of the environment or mention these numbers.
- Write in active voice. Use British, American, Scientific, International, and Commercial English (Basic English) for everything except dialogues. For dialogues, use the language that ordinary people in the 1980x would use.
- Use sarcasm and dry humor. Make sarcastic jokes in the internal monologue.`;

      // --- Core Data Management ---

      function loadNovels() {
        const data = localStorage.getItem(LS_KEY);
        try {
          novels = data ? JSON.parse(data) : [];
        } catch (e) {
          console.error("Error loading novels from local storage:", e);
          novels = []; // Reset if data is corrupted
        }
        // Ensure basic structure integrity
        novels.forEach((novel) => {
          novel.chapters = novel.chapters || [];
          novel.chapters.forEach((chapter) => {
            chapter.sceneBeats = chapter.sceneBeats || [];
            chapter.summary = chapter.summary || "";
            chapter.sceneBeats.forEach((beat) => {
              beat.generatedText = beat.generatedText || "";
            });
          });
        });
      }

      function saveNovels() {
        try {
          localStorage.setItem(LS_KEY, JSON.stringify(novels));
        } catch (e) {
          console.error("Error saving novels to local storage:", e);
          alert(
            "Error saving data. Local storage might be full or unavailable."
          );
        }
      }

      function getNovelById(id) {
        return novels.find((novel) => novel.id === id);
      }

      function getChapterById(novel, chapterId) {
        return novel?.chapters.find((chap) => chap.id === chapterId);
      }

      function getSceneBeatById(chapter, beatId) {
        return chapter?.sceneBeats.find((beat) => beat.id === beatId);
      }

      function generateId() {
        return Date.now().toString();
      }

      // --- Prompt Template Management ---

      function getPromptTemplate() {
        return localStorage.getItem(LS_TEMPLATE_KEY) || DEFAULT_PROMPT_TEMPLATE;
      }

      function savePromptTemplate(templateText) {
        try {
          localStorage.setItem(LS_TEMPLATE_KEY, templateText);
          return true;
        } catch (e) {
          console.error("Error saving prompt template:", e);
          alert("Error saving template. Local storage might be full.");
          return false;
        }
      }

      // --- UI Rendering ---

      function renderNovelList() {
        const novelListEl = document.getElementById("novelList");
        novelListEl.innerHTML = ""; // Clear current list

        if (novels.length === 0) {
          novelListEl.innerHTML =
            "<li>No novels found. Create one below or import one.</li>";
          return;
        }

        novels.forEach((novel) => {
          const li = document.createElement("li");
          li.innerHTML = `
                <span class="novel-item-title" onclick="openNovel('${
                  novel.id
                }')">${novel.title || "Untitled Novel"}</span>
                <div>
                    <button onclick="openNovel('${novel.id}')">Open</button>
                    <button class="delete-btn" onclick="deleteNovel('${
                      novel.id
                    }')">Delete</button>
                </div>
            `;
          novelListEl.appendChild(li);
        });
      }

      function updateNovelTitle(newTitle) {
        const novel = getNovelById(currentNovelId);
        if (novel) {
          novel.title = newTitle.trim() || "Untitled Novel";
          saveNovels();
        }
      }

      function renderNovelEditor() {
        const novel = getNovelById(currentNovelId);
        if (!novel) {
          console.error("Cannot render editor: Novel not found");
          showNovelList(); // Go back if novel doesn't exist
          return;
        }

        document.getElementById("editNovelTitle").value =
          novel.title || "Untitled Novel";
        const chaptersContainer = document.getElementById("chaptersContainer");
        chaptersContainer.innerHTML = ""; // Clear existing chapters

        const summaryStates = getChapterSummaryStates();

        novel.chapters.forEach((chapter, index) => {
          const chapterEl = document.createElement("div");
          chapterEl.classList.add("chapter");
          chapterEl.dataset.chapterId = chapter.id;
          chapterEl.dataset.chapterIndex = index;

          chapterEl.innerHTML = `
                <div class="chapter-header">
                    <input
                        type="text"
                        class="chapter-title"
                        value="${chapter.title || "Untitled Chapter"}"
                        onchange="updateChapterTitle('${novel.id}', '${
            chapter.id
          }', this.value)"
                        placeholder="Chapter Title"
                    />
                    <div class="chapter-controls">
                        <button class="move-btn" onclick="moveChapter('${
                          novel.id
                        }', ${index}, -1)" ${
            index === 0 ? "disabled" : ""
          }>↑</button>
                        <button class="move-btn" onclick="moveChapter('${
                          novel.id
                        }', ${index}, 1)" ${
            index === novel.chapters.length - 1 ? "disabled" : ""
          }>↓</button>
                        <button class="delete-btn" onclick="deleteChapter('${
                          novel.id
                        }', '${chapter.id}')">Delete Chapter</button>
                    </div>
                </div>

                <div class="scene-beats-container">
                    <!-- Scene beats will be injected here -->
                </div>

                <div class="add-beat-area">
                    <textarea class="new-beat-text" placeholder="Add new scene beat..."></textarea>
                    <button onclick="addSceneBeat('${novel.id}', '${
            chapter.id
          }')">+ Add Beat</button>
                </div>

                <hr style="margin: 15px 0;">

                <div>
                    <div class="summary-header" onclick="toggleChapterSummary('${
                      chapter.id
                    }')">
                        <span class="collapse-indicator">▼</span>
                        <h4>Chapter Summary</h4>
                    </div>
                    <div class="summary-section" id="summary-section-${
                      chapter.id
                    }">
                        <button onclick="copyChapterSummaryPrompt('${
                          novel.id
                        }', '${chapter.id}', this)">Copy Summary Prompt</button>
                        <span class="feedback">Copied!</span>
                        <textarea
                            class="summary-text-area"
                            placeholder="Paste chapter summary generated by AI here..."
                            onchange="updateChapterSummary('${novel.id}', '${
            chapter.id
          }', this.value)"
                        >${chapter.summary || ""}</textarea>
                    </div>
                </div>
            `;

          const summarySection = chapterEl.querySelector(
            `#summary-section-${chapter.id}`
          );
          const indicator = chapterEl.querySelector(".collapse-indicator");
          // Default to collapsed (true) if no state is stored for this chapter
          const isCollapsed = summaryStates[chapter.id] ?? true;

          if (summarySection && indicator) {
            if (isCollapsed) {
              summarySection.classList.add("collapsed");
              indicator.style.transform = "rotate(-90deg)";
            } else {
              summarySection.classList.remove("collapsed");
              indicator.style.transform = ""; // Default upright arrow
            }
          }

          chaptersContainer.appendChild(chapterEl);
          renderSceneBeats(
            novel.id,
            chapter.id,
            chapterEl.querySelector(".scene-beats-container")
          );
        });
      }

      function renderSceneBeats(novelId, chapterId, container) {
        const novel = getNovelById(novelId);
        const chapter = getChapterById(novel, chapterId);
        container.innerHTML = ""; // Clear existing beats

        if (!chapter || chapter.sceneBeats.length === 0) {
          container.innerHTML =
            '<p style="color: #888; font-style: italic;">No scene beats yet.</p>';
          return;
        }

        chapter.sceneBeats.forEach((beat, index) => {
          const beatEl = document.createElement("div");
          beatEl.classList.add("scene-beat");
          beatEl.dataset.beatId = beat.id;
          beatEl.dataset.beatIndex = index;

          beatEl.innerHTML = `
                <textarea
                    class="beat-text-area"
                    placeholder="Scene beat description..."
                    onchange="updateSceneBeatText('${novelId}', '${chapterId}', '${
            beat.id
          }', this.value)"
                >${beat.text || ""}</textarea>

                <div class="beat-controls">
                    <button class="move-btn" onclick="moveSceneBeat('${novelId}', '${chapterId}', ${index}, -1)" ${
            index === 0 ? "disabled" : ""
          }>↑</button>
                    <button class="move-btn" onclick="moveSceneBeat('${novelId}', '${chapterId}', ${index}, 1)" ${
            index === chapter.sceneBeats.length - 1 ? "disabled" : ""
          }>↓</button>
                    <button onclick="showPromptDialog('${novelId}', '${chapterId}', '${
            beat.id
          }')">Show Scene Beat Prompt</button>
                    <button class="delete-btn" onclick="deleteSceneBeat('${novelId}', '${chapterId}', '${
            beat.id
          }')">Delete Beat</button>
                </div>
                 <textarea
                    class="generated-text-area"
                    placeholder="Paste AI generated content here..."
                    onchange="updateGeneratedText('${novelId}', '${chapterId}', '${
            beat.id
          }', this.value)"
                >${beat.generatedText || ""}</textarea>
            `;
          container.appendChild(beatEl);
        });
      }

      // --- Render chapter filter dropdown ---
      function updateChapterFilter() {
        if (!currentNovelId) return;
        
        const novel = getNovelById(currentNovelId);
        if (!novel) return;
        
        const filterSelect = document.getElementById('chapterFilter');
        if (!filterSelect) return;
        
        // Save current selection if any
        const currentValue = filterSelect.value;
        
        // Clear existing options except for "All Chapters"
        while (filterSelect.options.length > 1) {
          filterSelect.remove(1);
        }
        
        // Add option for each chapter
        novel.chapters.forEach((chapter, index) => {
          const option = document.createElement('option');
          option.value = chapter.id;
          option.textContent = chapter.title || `Chapter ${index + 1}`;
          filterSelect.appendChild(option);
        });
        
        // Restore selection if possible
        if (currentValue && [...filterSelect.options].some(opt => opt.value === currentValue)) {
          filterSelect.value = currentValue;
        } else {
          filterSelect.value = 'all'; // Default to All Chapters
        }
        
        // Apply current filter
        filterChapters(filterSelect.value);
      }
      
      // --- Filter chapters based on selection ---
      function filterChapters(chapterId) {
        const chaptersContainer = document.getElementById('chaptersContainer');
        const chapterElements = chaptersContainer.querySelectorAll('.chapter');
        
        if (chapterId === 'all') {
          // Show all chapters
          chapterElements.forEach(el => {
            el.style.display = 'block';
          });
        } else {
          // Show only the selected chapter
          chapterElements.forEach(el => {
            el.style.display = el.dataset.chapterId === chapterId ? 'block' : 'none';
          });
        }
      }

      // --- UI Navigation ---

      function showView(viewId) {
        document.getElementById("novelListView").style.display = "none";
        document.getElementById("novelEditorView").style.display = "none";
        document.getElementById("settingsView").style.display = "none";

        const view = document.getElementById(viewId);
        if (view) {
          view.style.display = "block";
        } else {
          console.error("Attempted to show unknown view:", viewId);
          document.getElementById("novelListView").style.display = "block"; // Fallback
        }
      }

      function showNovelList() {
        currentNovelId = null;
        showView("novelListView");
        document.getElementById("newNovelTitle").value = ""; // Clear input field
        const importArea = document.querySelector(".import-area");
        importArea.classList.remove("show"); // Hide import area if open
        document.getElementById("importText").value = "";
        renderNovelList();
      }

      function showNovelEditor() {
        if (!currentNovelId) return;
        showView("novelEditorView");
        renderNovelEditor();
        updateChapterFilter(); // Update the chapter filter dropdown
      }

      function showSettings() {
        showView("settingsView");
        document.getElementById("promptTemplateTextarea").value =
          getPromptTemplate();
      }

      function hideSettings() {
        // Go back to the novel list view after closing settings
        showNovelList();
      }

      // --- Settings Actions ---

      function saveTemplateSettings() {
        const templateText = document.getElementById(
          "promptTemplateTextarea"
        ).value;
        if (savePromptTemplate(templateText)) {
          // Show feedback
          const feedbackEl = document.getElementById("settingsFeedback");
          feedbackEl.classList.add("show");
          setTimeout(() => {
            feedbackEl.classList.remove("show");
          }, 1500);
        }
      }

      function resetTemplateToDefault() {
        if (
          confirm(
            "Are you sure you want to reset the prompt template to its default value? Unsaved changes will be lost."
          )
        ) {
          document.getElementById("promptTemplateTextarea").value =
            DEFAULT_PROMPT_TEMPLATE;
          // Optionally, you could save immediately after reset:
          // savePromptTemplate(DEFAULT_PROMPT_TEMPLATE);
          // alert("Template reset to default.");
        }
      }

      // --- Novel Actions ---

      function createNovel() {
        const titleInput = document.getElementById("newNovelTitle");
        const title = titleInput.value.trim() || "Untitled Novel";
        const newNovel = {
          id: generateId(),
          title: title,
          chapters: [],
        };
        novels.push(newNovel);
        saveNovels();
        titleInput.value = ""; // Clear input
        openNovel(newNovel.id); // Automatically open the new novel
      }

      function openNovel(id) {
        currentNovelId = id;
        showNovelEditor();
      }

      function deleteNovel(id) {
        const novelToDelete = getNovelById(id);
        if (!novelToDelete) return;
        if (
          confirm(
            `Are you sure you want to delete the novel "${
              novelToDelete.title || "Untitled Novel"
            }"? This cannot be undone.`
          )
        ) {
          novels = novels.filter((novel) => novel.id !== id);
          saveNovels();
          renderNovelList(); // Refresh list view
        }
      }
      function deleteCurrentNovel() {
        if (currentNovelId) {
          const novelToDelete = getNovelById(currentNovelId);
          if (!novelToDelete) return;
          if (
            confirm(
              `Are you sure you want to delete the novel "${
                novelToDelete.title || "Untitled Novel"
              }"? This cannot be undone.`
            )
          ) {
            novels = novels.filter((novel) => novel.id !== currentNovelId);
            saveNovels();
            showNovelList(); // Go back to list view
          }
        }
      }

      // --- Chapter Actions ---

      function addChapter() {
        const novel = getNovelById(currentNovelId);
        if (!novel) return;

        const newChapter = {
          id: generateId(),
          title: `Chapter ${novel.chapters.length + 1}`,
          sceneBeats: [],
          summary: "",
        };
        novel.chapters.push(newChapter);
        saveNovels();
        renderNovelEditor();
        updateChapterFilter(); // Update filter after adding a chapter
      }

      function deleteChapter(novelId, chapterId) {
        const novel = getNovelById(novelId);
        if (!novel) return;
        const chapter = getChapterById(novel, chapterId);

        if (
          confirm(
            `Are you sure you want to delete "${
              chapter?.title || "this chapter"
            }" and all its scene beats?`
          )
        ) {
          novel.chapters = novel.chapters.filter(
            (chap) => chap.id !== chapterId
          );
          removeChapterSummaryState(chapterId);
          saveNovels();
          renderNovelEditor(); // Re-render the editor view
          updateChapterFilter(); // Update filter after deleting
        }
      }

      function updateChapterTitle(novelId, chapterId, newTitle) {
        const novel = getNovelById(novelId);
        const chapter = getChapterById(novel, chapterId);
        if (chapter) {
          chapter.title = newTitle.trim() || "Untitled Chapter";
          saveNovels();
          updateChapterFilter(); // Update filter when title changes
        }
      }

      // --- Update moveChapter to refresh the filter ---
      function moveChapter(novelId, chapterIndex, direction) {
        // direction: -1 for up, 1 for down
        const novel = getNovelById(novelId);
        if (!novel) return;

        const newIndex = chapterIndex + direction;
        if (newIndex < 0 || newIndex >= novel.chapters.length) {
          return; // Invalid move
        }

        // Swap elements using array destructuring for conciseness
        [novel.chapters[chapterIndex], novel.chapters[newIndex]] = [
          novel.chapters[newIndex],
          novel.chapters[chapterIndex],
        ];

        saveNovels();
        renderNovelEditor(); // Re-render to reflect new order
        updateChapterFilter(); // Update filter after moving chapters
      }

      // --- Scene Beat Actions ---

      function addSceneBeat(novelId, chapterId) {
        const novel = getNovelById(novelId);
        const chapter = getChapterById(novel, chapterId);
        if (!chapter) return;

        // Find the specific chapter element to get the text from the correct input
        const chapterElement = document.querySelector(
          `.chapter[data-chapter-id="${chapterId}"]`
        );
        if (!chapterElement) return; // Should not happen normally
        const newBeatTextArea = chapterElement.querySelector(".new-beat-text");
        const text = newBeatTextArea.value.trim();

        if (!text) {
          alert("Please enter some text for the scene beat.");
          return;
        }

        const newBeat = {
          id: generateId(),
          text: text,
          generatedText: "",
        };
        chapter.sceneBeats.push(newBeat);
        saveNovels();
        newBeatTextArea.value = ""; // Clear the input field

        // Re-render just the scene beats for this chapter for efficiency
        const beatsContainer = chapterElement.querySelector(
          ".scene-beats-container"
        );
        renderSceneBeats(novelId, chapterId, beatsContainer);
        newBeatTextArea.focus(); // Focus input for quick next entry

        // Ensure summaries are properly initialized after adding content
        initializeCollapsibleSummaries();
      }

      function deleteSceneBeat(novelId, chapterId, beatId) {
        const novel = getNovelById(novelId);
        const chapter = getChapterById(novel, chapterId);
        if (!chapter) return;

        if (confirm("Are you sure you want to delete this scene beat?")) {
          const initialLength = chapter.sceneBeats.length;
          chapter.sceneBeats = chapter.sceneBeats.filter(
            (beat) => beat.id !== beatId
          );
          if (chapter.sceneBeats.length < initialLength) {
            // Check if deletion happened
            saveNovels();
            // Re-render just the scene beats for this chapter
            const chapterElement = document.querySelector(
              `.chapter[data-chapter-id="${chapterId}"]`
            );
            if (chapterElement) {
              // Check if element exists before querying
              const beatsContainer = chapterElement.querySelector(
                ".scene-beats-container"
              );
              renderSceneBeats(novelId, chapterId, beatsContainer);
            } else {
              renderNovelEditor(); // Fallback to full render if element not found
            }
          }
        }
      }

      function updateSceneBeatText(novelId, chapterId, beatId, newText) {
        const novel = getNovelById(novelId);
        const chapter = getChapterById(novel, chapterId);
        const beat = getSceneBeatById(chapter, beatId);
        if (beat && beat.text !== newText) {
          // Only save if text changed
          beat.text = newText; // Keep whitespace as entered
          saveNovels();
        }
      }

      function updateGeneratedText(novelId, chapterId, beatId, genText) {
        const novel = getNovelById(novelId);
        const chapter = getChapterById(novel, chapterId);
        const beat = getSceneBeatById(chapter, beatId);
        if (beat && beat.generatedText !== genText) {
          // Only save if text changed
          beat.generatedText = genText;
          saveNovels();
        }
      }

      function moveSceneBeat(novelId, chapterId, beatIndex, direction) {
        // -1 up, 1 down
        const novel = getNovelById(novelId);
        const chapter = getChapterById(novel, chapterId);
        if (!chapter) return;

        const newIndex = beatIndex + direction;
        if (newIndex < 0 || newIndex >= chapter.sceneBeats.length) {
          return; // Invalid move
        }

        // Swap elements
        [chapter.sceneBeats[beatIndex], chapter.sceneBeats[newIndex]] = [
          chapter.sceneBeats[newIndex],
          chapter.sceneBeats[beatIndex],
        ];

        saveNovels();
        // Re-render just the scene beats for this chapter
        const chapterElement = document.querySelector(
          `.chapter[data-chapter-id="${chapterId}"]`
        );
        if (chapterElement) {
          // Check if element exists before querying
          const beatsContainer = chapterElement.querySelector(
            ".scene-beats-container"
          );
          renderSceneBeats(novelId, chapterId, beatsContainer);
        } else {
          renderNovelEditor(); // Fallback to full render
        }
      }

      // --- Prompt Generation & Clipboard ---

      function showPromptDialog(novelId, chapterId, beatId) {
        const novel = getNovelById(novelId);
        const chapter = getChapterById(novel, chapterId);
        const beat = getSceneBeatById(chapter, beatId);
        if (!novel || !chapter || !beat) return;

        // Generate the prompt
        const chapterIndex = novel.chapters.findIndex(
          (ch) => ch.id === chapterId
        );
        const beatIndex = chapter.sceneBeats.findIndex((b) => b.id === beatId);

        // Build story so far section
        let storySoFar = "";

        // Add previous chapters' summaries
        for (let i = 0; i < chapterIndex; i++) {
          const prevChapter = novel.chapters[i];
          if (prevChapter.summary) {
            storySoFar += `Summary of Chapter ${i + 1}: ${
              prevChapter.title || "Untitled"
            }\n${prevChapter.summary}\n\n`;
          } else {
            // Fallback: Use generated text of previous chapter beats if no summary
            const prevChapterText = prevChapter.sceneBeats
              .map((b) => b.generatedText || "")
              .filter(Boolean)
              .join("\n");
            if (prevChapterText) {
              storySoFar += `Content from Chapter ${i + 1}: ${
                prevChapter.title || "Untitled"
              }\n${prevChapterText}\n\n`;
            }
          }
        }

        // Add current chapter's previous generated beats
        for (let i = 0; i < beatIndex; i++) {
          const prevBeat = chapter.sceneBeats[i];
          if (prevBeat.generatedText) {
            storySoFar += prevBeat.generatedText + "\n\n";
          }
        }
        storySoFar = storySoFar.trim();

        // Get the template and prepare the prompt
        const template = getPromptTemplate();
        const instructionsText = beat.text || "";
        let prompt = template.replace(
          "{storySoFar}",
          storySoFar || "This is the beginning of the story."
        );
        prompt = prompt.replace("{instructions}", instructionsText);

        // Show the prompt in the modal
        document.getElementById("promptTextarea").value = prompt.trim();

        // Display the modal
        const modal = document.getElementById("promptModal");
        modal.style.display = "flex";
      }

      function closePromptModal() {
        const modal = document.getElementById("promptModal");
        modal.style.display = "none";
      }

      function copyPromptFromModal() {
        const promptText = document.getElementById("promptTextarea").value;
        navigator.clipboard
          .writeText(promptText)
          .then(() => {
            // Show feedback inside the modal
            const copyButton = document.querySelector("#promptModal button");
            if (copyButton) {
              const originalText = copyButton.textContent;
              copyButton.textContent = "Copied!";
              setTimeout(() => {
                copyButton.textContent = originalText;
              }, 1500);
            }
            console.log("Prompt copied to clipboard");
          })
          .catch((err) => {
            console.error("Failed to copy text: ", err);
            alert(
              "Failed to copy prompt. Your browser might not support this feature or permission was denied."
            );
          });
      }

      function showFeedback(buttonElement) {
        // Show feedback next to the button
        const feedbackEl = buttonElement.nextElementSibling;
        if (
          feedbackEl &&
          (feedbackEl.classList.contains("feedback") ||
            feedbackEl.id === "settingsFeedback")
        ) {
          feedbackEl.classList.add("show");
          setTimeout(() => {
            feedbackEl.classList.remove("show");
          }, 1500); // Hide after 1.5 seconds
        }
      }

      function copyToClipboard(text, buttonElement) {
        navigator.clipboard
          .writeText(text)
          .then(() => {
            showFeedback(buttonElement);
            console.log("Text copied to clipboard");
          })
          .catch((err) => {
            console.error("Failed to copy text: ", err);
            alert(
              "Failed to copy text. Your browser might not support this feature or permission was denied."
            );
          });
      }

      function copyChapterSummaryPrompt(novelId, chapterId, buttonElement) {
        const novel = getNovelById(novelId);
        const chapter = getChapterById(novel, chapterId);
        if (!chapter) return;

        // Collect only the generated text for summary, assuming that's what should be summarized.
        let chapterText = chapter.sceneBeats
          .map((beat) => beat.generatedText || beat.text)
          .filter(Boolean)
          .join("\n\n");
        const prompt = `Please write a concise summary of the following chapter content:\n\n${chapterText}`;
        copyToClipboard(prompt, buttonElement);
      }

      function copyContinuePrompt(novelId, chapterId, beatId, buttonElement) {
        const novel = getNovelById(novelId);
        const chapter = getChapterById(novel, chapterId);
        const beat = getSceneBeatById(chapter, beatId);
        if (!novel || !chapter || !beat) return;

        const chapterIndex = novel.chapters.findIndex(
          (ch) => ch.id === chapterId
        );
        const beatIndex = chapter.sceneBeats.findIndex((b) => b.id === beatId);

        // Build story so far section
        let storySoFar = "";

        // Add previous chapters' summaries (if they exist)
        for (let i = 0; i < chapterIndex; i++) {
          const prevChapter = novel.chapters[i];
          if (prevChapter.summary) {
            storySoFar += `Summary of Chapter ${i + 1}: ${
              prevChapter.title || "Untitled"
            }\n${prevChapter.summary}\n\n`;
          } else {
            // Fallback: Use generated text of previous chapter beats if no summary
            const prevChapterText = prevChapter.sceneBeats
              .map((b) => b.generatedText || "") // Prioritize generated text
              .filter(Boolean) // Remove empty strings
              .join("\n");
            if (prevChapterText) {
              storySoFar += `Content from Chapter ${i + 1}: ${
                prevChapter.title || "Untitled"
              }\n${prevChapterText}\n\n`;
            }
          }
        }

        // Add current chapter's previous *generated* beats' text
        // Important: Use the AI *output* from previous beats as context
        for (let i = 0; i < beatIndex; i++) {
          const prevBeat = chapter.sceneBeats[i];
          if (prevBeat.generatedText) {
            // Only include if there's generated text
            storySoFar += prevBeat.generatedText + "\n\n"; // Double newline between beats
          }
        }
        storySoFar = storySoFar.trim(); // Remove trailing newlines

        // Get the template
        const template = getPromptTemplate();

        // Prepare the instructions (current beat's text)
        const instructionsText = beat.text || "";

        // Replace placeholders
        let prompt = template.replace(
          "{storySoFar}",
          storySoFar || "This is the beginning of the story."
        ); // Add fallback if storySoFar is empty
        prompt = prompt.replace("{instructions}", instructionsText);

        copyToClipboard(prompt.trim(), buttonElement);
      }

      // --- Import / Export ---

      function exportNovel(buttonElement) {
        const novel = getNovelById(currentNovelId);
        if (!novel) return;

        let markdown = `# ${novel.title}\n\n`;

        novel.chapters.forEach((chapter, chapterIndex) => {
          markdown += `## ${chapter.title}\n\n`;

          if (chapter.summary) {
            markdown += `### Summary\n\n${chapter.summary}\n\n`;
          }

          markdown += `### Scene Beats\n\n`;
          chapter.sceneBeats.forEach((beat, beatIndex) => {
            // Consistent numbering based on order
            markdown += `#### Beat ${beatIndex + 1}\n\n`;
            markdown += `**Scene Description:**\n${beat.text || ""}\n\n`;
            if (beat.generatedText) {
              markdown += `**Generated Content:**\n${beat.generatedText}\n\n`;
            } else {
              markdown += `**Generated Content:**\n\n\n`; // Ensure structure is maintained even if empty
            }
          });
          markdown += "\n"; // Add extra newline after last beat of chapter
        });

        copyToClipboard(markdown.trim(), buttonElement);
      }

      function toggleImportArea() {
        const importArea = document.querySelector(".import-area");
        importArea.classList.toggle("show");
        if (!importArea.classList.contains("show")) {
          document.getElementById("importText").value = "";
        } else {
          document.getElementById("importText").focus();
        }
      }

      function importNovel() {
        const text = document.getElementById("importText").value.trim();
        if (!text) {
          alert("Please paste the exported novel markdown content first.");
          return;
        }

        try {
          const novel = {
            id: generateId(),
            title: "Imported Novel", // Default title
            chapters: [],
          };

          const lines = text.split("\n");
          let currentChapter = null;
          let currentBeat = null;
          let readingMode = null; // null | 'summary' | 'description' | 'generated'

          lines.forEach((line) => {
            const trimmedLine = line.trim();

            if (trimmedLine.startsWith("# ")) {
              novel.title = trimmedLine.substring(2).trim();
            } else if (trimmedLine.startsWith("## ")) {
              currentChapter = {
                id: generateId(),
                title: trimmedLine.substring(3).trim(),
                summary: "",
                sceneBeats: [],
              };
              novel.chapters.push(currentChapter);
              currentBeat = null; // Reset beat context
              readingMode = null;
            } else if (trimmedLine === "### Summary" && currentChapter) {
              readingMode = "summary";
            } else if (trimmedLine === "### Scene Beats" && currentChapter) {
              readingMode = null; // End summary reading if any
            } else if (trimmedLine.startsWith("#### Beat") && currentChapter) {
              currentBeat = {
                id: generateId(),
                text: "",
                generatedText: "",
              };
              currentChapter.sceneBeats.push(currentBeat);
              readingMode = null; // End previous reading mode
            } else if (
              trimmedLine === "**Scene Description:**" &&
              currentBeat
            ) {
              readingMode = "description";
              currentBeat.text = ""; // Initialize/clear
            } else if (
              trimmedLine === "**Generated Content:**" &&
              currentBeat
            ) {
              readingMode = "generated";
              currentBeat.generatedText = ""; // Initialize/clear
            } else if (currentChapter) {
              // Append line to the correct field based on readingMode
              if (readingMode === "summary") {
                // Append with newline if summary already has content
                currentChapter.summary +=
                  (currentChapter.summary ? "\n" : "") + line;
              } else if (readingMode === "description" && currentBeat) {
                currentBeat.text += (currentBeat.text ? "\n" : "") + line;
              } else if (readingMode === "generated" && currentBeat) {
                currentBeat.generatedText +=
                  (currentBeat.generatedText ? "\n" : "") + line;
              }
            }
          });

          // Trim whitespace from imported fields
          novel.chapters.forEach((ch) => {
            ch.summary = ch.summary.trim();
            ch.sceneBeats.forEach((b) => {
              b.text = b.text.trim();
              b.generatedText = b.generatedText.trim();
            });
          });

          novels.push(novel);
          saveNovels();
          toggleImportArea(); // Close the import area
          showNovelList(); // Refresh the list
          alert(`Novel "${novel.title}" imported successfully!`);
        } catch (e) {
          console.error("Import error:", e);
          alert(
            "Error importing novel. Please check the format. It should be the Markdown exported from this tool."
          );
        }
      }

      // --- Collapsible Summary State Management ---

      const LS_SUMMARY_STATE_KEY = "chapterSummaryStates";

      function getChapterSummaryStates() {
        try {
          return JSON.parse(localStorage.getItem(LS_SUMMARY_STATE_KEY) || "{}");
        } catch (e) {
          console.error("Error reading summary states:", e);
          return {}; // Return empty object on error
        }
      }

      function saveChapterSummaryState(chapterId, isCollapsed) {
        const states = getChapterSummaryStates();
        states[chapterId] = isCollapsed; // true if collapsed, false if expanded
        try {
          localStorage.setItem(LS_SUMMARY_STATE_KEY, JSON.stringify(states));
        } catch (e) {
          console.error("Error saving summary state:", e);
          // Optionally alert the user if saving fails critically
        }
      }

      function removeChapterSummaryState(chapterId) {
        const states = getChapterSummaryStates();
        if (states.hasOwnProperty(chapterId)) {
          delete states[chapterId];
          try {
            localStorage.setItem(LS_SUMMARY_STATE_KEY, JSON.stringify(states));
          } catch (e) {
            console.error("Error removing summary state:", e);
          }
        }
      }

      function initializeCollapsibleSummaries() {
        // Get stored visibility states
        const storedStates = JSON.parse(
          localStorage.getItem("chapterSummaryStates") || "{}"
        );

        document.querySelectorAll(".summary-section").forEach((section) => {
          const chapterId = section.id.replace("summary-section-", "");
          if (storedStates[chapterId] === false) {
            section.classList.remove("collapsed");
            const indicator = section.previousElementSibling.querySelector(
              ".collapse-indicator"
            );
            if (indicator) indicator.style.transform = "";
          } else {
            section.classList.add("collapsed");
          }
        });
      }

      // Initialize summaries whenever content is added
      function addChapter() {
        const novel = getNovelById(currentNovelId);
        if (!novel) return;

        const newChapter = {
          id: generateId(),
          title: `Chapter ${novel.chapters.length + 1}`,
          sceneBeats: [],
          summary: "",
        };
        novel.chapters.push(newChapter);
        saveNovels();
        renderNovelEditor();
        updateChapterFilter(); // Update filter after adding a chapter
      }

      function addSceneBeat(novelId, chapterId) {
        const novel = getNovelById(novelId);
        const chapter = getChapterById(novel, chapterId);
        if (!chapter) return;

        // Find the specific chapter element to get the text from the correct input
        const chapterElement = document.querySelector(
          `.chapter[data-chapter-id="${chapterId}"]`
        );
        if (!chapterElement) return; // Should not happen normally
        const newBeatTextArea = chapterElement.querySelector(".new-beat-text");
        const text = newBeatTextArea.value.trim();

        if (!text) {
          alert("Please enter some text for the scene beat.");
          return;
        }

        const newBeat = {
          id: generateId(),
          text: text,
          generatedText: "",
        };
        chapter.sceneBeats.push(newBeat);
        saveNovels();
        newBeatTextArea.value = ""; // Clear the input field

        // Re-render just the scene beats for this chapter for efficiency
        const beatsContainer = chapterElement.querySelector(
          ".scene-beats-container"
        );
        renderSceneBeats(novelId, chapterId, beatsContainer);
        newBeatTextArea.focus(); // Focus input for quick next entry

        // Ensure summaries are properly initialized after adding content
        initializeCollapsibleSummaries();
      }

      function toggleChapterSummary(chapterId) {
        const summarySection = document.getElementById(
          `summary-section-${chapterId}`
        );
        const indicator = summarySection?.previousElementSibling?.querySelector(
          ".collapse-indicator"
        ); // Find indicator safely

        if (summarySection && indicator) {
          summarySection.classList.toggle("collapsed");
          const isCollapsed = summarySection.classList.contains("collapsed");

          // Update arrow direction visually
          indicator.style.transform = isCollapsed ? "rotate(-90deg)" : "";

          // Save the state to localStorage
          saveChapterSummaryState(chapterId, isCollapsed);
        } else {
          console.warn(
            `Could not find summary section or indicator for chapter ${chapterId}`
          );
        }
      }

      // --- Initialization ---

      document.addEventListener("DOMContentLoaded", () => {
        loadNovels();
        showNovelList(); // Start by showing the list of novels
      });
    </script>
  </body>
</html>

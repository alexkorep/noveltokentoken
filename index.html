<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>React AI-Assisted Novel Editor</title>
    <!-- Include existing CSS -->
    <style>
      /* --- Existing styles --- */
      body {
        font-family: sans-serif;
        line-height: 1.6;
        margin: 20px;
        background-color: #f4f4f4;
        color: #333;
      }

      h1,
      h2,
      h3 {
        color: #333;
      }

      button {
        padding: 8px 12px;
        margin: 5px 2px;
        cursor: pointer;
        background-color: #5c67f2;
        color: white;
        border: none;
        border-radius: 4px;
      }

      button:hover {
        background-color: #4a54e1;
      }

      button.delete-btn {
        background-color: #e74c3c;
      }
      button.delete-btn:hover {
        background-color: #c0392b;
      }

      button.move-btn {
        background-color: #f39c12;
        font-weight: bold;
        padding: 4px 8px;
        min-width: 30px;
      }
      button.move-btn:hover {
        background-color: #e67e22;
      }
      button:disabled {
        background-color: #ccc;
        cursor: not-allowed;
      }

      button.secondary-btn {
        background-color: #7f8c8d;
      }
      button.secondary-btn:hover {
        background-color: #6c7a7b;
      }

      .container {
        max-width: 900px;
        margin: auto;
        background: white;
        padding: 20px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        border-radius: 8px;
      }

      /* Views */
      .view {
        margin-top: 20px;
      }

      #novelList {
        list-style: none;
        padding: 0;
      }

      #novelList li {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
        border-bottom: 1px solid #eee;
      }
      #novelList li:last-child {
        border-bottom: none;
      }

      .novel-item-title {
        font-weight: bold;
        cursor: pointer;
      }
      .novel-item-title:hover {
        color: #5c67f2;
      }

      .chapter {
        border: 1px solid #ccc;
        border-radius: 5px;
        padding: 15px;
        margin-bottom: 20px;
        background-color: #fff;
      }

      .chapter-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        flex-wrap: wrap; /* Allow wrapping on smaller screens */
      }

      .chapter-title {
        font-size: 1.2em;
        font-weight: bold;
        border: none;
        padding: 5px;
        flex-grow: 1; /* Allow title to take available space */
        margin-right: 10px; /* Space between title and buttons */
        border: 1px solid transparent; /* Add border for focus state consistency */
      }
      .chapter-title:focus {
        outline: 1px solid #5c67f2;
        background-color: #f0f0ff;
        border: 1px solid #ccc;
      }

      .chapter-controls button,
      .beat-controls button {
        margin-left: 5px;
      }

      .scene-beat {
        border: 1px dashed #ddd;
        padding: 10px;
        margin-top: 10px;
        background-color: #f9f9f9;
        border-radius: 4px;
      }

      textarea {
        width: 98%; /* Adjusted for potential scrollbars */
        min-height: 60px;
        margin-top: 5px;
        margin-bottom: 5px;
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-family: inherit;
        font-size: 1em;
        resize: vertical; /* Allow vertical resize */
        box-sizing: border-box; /* Include padding and border */
      }

      .beat-text-area {
        min-height: 40px;
      }

      .generated-text-area,
      .summary-text-area {
        min-height: 80px;
        background-color: #e8f0fe; /* Light blue background */
      }

      .beat-controls {
        display: flex;
        justify-content: flex-end;
        align-items: center;
        margin-top: 5px;
        flex-wrap: wrap;
      }

      .add-beat-area {
        margin-top: 15px;
        display: flex;
        align-items: center;
      }

      .add-beat-area textarea {
        flex-grow: 1;
        margin-right: 10px;
        min-height: 30px;
      }

      .feedback {
        color: green;
        font-size: 0.9em;
        margin-left: 10px;
        display: inline-block;
        opacity: 0;
        transition: opacity 0.5s ease-out;
      }
      .feedback.show {
        opacity: 1;
      }

      input[type="text"] {
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        margin-right: 5px; /* Add some spacing */
      }

      .novel-title-edit input[type="text"] {
        font-size: 1.5em;
        margin-bottom: 10px;
        width: calc(100% - 20px); /* Adjust width */
      }

      .import-export-area {
        margin: 10px 0;
        padding: 10px;
        background: #f8f8f8;
        border-radius: 4px;
      }

      .import-area {
        /* Display handled by React state */
        margin-top: 10px;
      }

      .import-area textarea {
        width: 100%;
        min-height: 200px;
        margin: 10px 0;
        box-sizing: border-box;
      }

      /* --- Settings Styles (No separate view now) --- */
      .template-help {
        font-size: 0.9em;
        color: #555;
        margin-bottom: 10px;
      }
      .template-help code {
        background-color: #eee;
        padding: 2px 4px;
        border-radius: 3px;
      }

      /* --- Modal Dialog Styles --- */
      .modal-overlay {
        /* Display handled by React state */
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 1000;
        display: flex; /* Use flex for centering */
        justify-content: center;
        align-items: center;
      }

      .modal-dialog {
        background-color: white;
        max-width: 80%;
        width: 800px;
        max-height: 80vh;
        border-radius: 8px;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
        display: flex;
        flex-direction: column;
      }

      .modal-header {
        padding: 15px;
        border-bottom: 1px solid #eee;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .modal-title {
        font-size: 1.2em;
        font-weight: bold;
        margin: 0;
      }

      .modal-close {
        background: none;
        border: none;
        font-size: 1.5em;
        cursor: pointer;
        color: #777;
        padding: 0;
        margin: 0;
        line-height: 1; /* Ensure tight fit */
      }

      .modal-body {
        padding: 15px;
        overflow-y: auto;
        flex-grow: 1;
      }

      .modal-footer {
        padding: 15px;
        border-top: 1px solid #eee;
        display: flex;
        justify-content: flex-end;
      }

      .modal-footer button {
        margin-left: 10px;
      }

      .prompt-textarea {
        width: 100%;
        min-height: 300px;
        font-family: monospace;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        margin-bottom: 10px;
        resize: vertical;
        box-sizing: border-box;
      }

      /* --- Collapsible summary styles --- */
      .summary-section {
        transition: max-height 0.3s ease-out;
        overflow: hidden;
        max-height: 500px; /* Default expanded height large enough */
      }

      .summary-section.collapsed {
        max-height: 0;
      }

      .summary-header {
        display: flex;
        align-items: center;
        cursor: pointer;
        gap: 5px;
        margin-bottom: 10px; /* Add space below header */
      }

      .summary-header h4 {
        margin: 0;
      }

      .collapse-indicator {
        font-size: 18px;
        line-height: 1;
        transition: transform 0.3s;
        display: inline-block;
      }

      .summary-header.collapsed .collapse-indicator {
        transform: rotate(-90deg);
      }

      /* Chapter Filter */
      .chapter-filter {
        margin: 10px 0;
      }

      /* Add Beat Textarea Focus Style */
      .add-beat-area textarea:focus {
        outline: 1px solid #5c67f2;
      }

      /* Prevent layout shift from feedback */
      .feedback-container {
        display: inline-block;
        min-width: 60px; /* Adjust as needed */
        text-align: left;
      }
    </style>
  </head>
  <body>
    <!-- Root element for React -->
    <div id="root"></div>

    <!-- React and Babel CDNs -->
    <script
      src="https://unpkg.com/react@18/umd/react.development.js"
      crossorigin
    ></script>
    <script
      src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
      crossorigin
    ></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

    <!-- React Application Code (using Babel) -->
    <script type="text/babel">
      const { useState, useEffect, useCallback, useMemo } = React;

      // --- Constants ---
      const LS_KEY = "novels_react"; // Use a different key for React version
      const LS_SUMMARY_STATE_KEY = "chapterSummaryStates_react";
      const DEFAULT_PROMPT_TEMPLATE = `The story so far:
{storySoFar}

You are an expert fiction writer. Continue the story and write about 400 words for the following instructions:
{instructions}

NEVER conclude the scene on your own, follow the beat instructions very closely. NEVER end with foreshadowing. NEVER write further than what I prompt you with. AVOID imagining possible endings, NEVER deviate from the instructions.

STOP EARLY if the continuation contains what was required in the instructions. You do not need to fill out the full amount of words possible.

- Do not use bold or italic font.
- Do not use expressions like "mechanical precision," "with rapid efficiency," or "at a steady pace", "her stride controlled, efficient", "this is not ideal".
- CT32F, from whose perspective the story is told, cannot feel or detect emotions in others. She cannot feel pain. She cannot assess things like beauty, nor does she feel the wind or cold.
- Do not measure parameters of the environment or mention these numbers.
- Write in active voice. Use British, American, Scientific, International, and Commercial English (Basic English) for everything except dialogues. For dialogues, use the language that ordinary people in the 1980x would use.
- Use sarcasm and dry humor. Make sarcastic jokes in the internal monologue.`;

      // --- Helper Functions ---
      function generateId() {
        return (
          Date.now().toString(36) + Math.random().toString(36).substring(2)
        );
      }

      // ****** FIXED HERE ******
      function getEffectiveTemplate(novel) {
        // Replace novel?.template with (novel && novel.template)
        return (novel && novel.template) || DEFAULT_PROMPT_TEMPLATE;
      }
      // ****** END FIX ******

      // Simple copy-to-clipboard helper
      function copyToClipboard(text) {
        if (!text) return Promise.reject(new Error("Nothing to copy"));
        return navigator.clipboard.writeText(text);
      }

      // --- Modal Component ---
      function Modal({ title, children, footer, onClose }) {
        return (
          <div className="modal-overlay">
            <div className="modal-dialog">
              <div className="modal-header">
                <h3 className="modal-title">{title}</h3>
                <button className="modal-close" onClick={onClose}>
                  ×
                </button>
              </div>
              <div className="modal-body">{children}</div>
              <div className="modal-footer">{footer}</div>
            </div>
          </div>
        );
      }

      // --- Feedback Component ---
      function FeedbackMessage({ show, message = "Copied!" }) {
        return (
          <span className={`feedback ${show ? "show" : ""}`}>{message}</span>
        );
      }

      // --- SceneBeat Component ---
      function SceneBeat({
        novelId,
        chapterId,
        beat,
        beatIndex,
        totalBeats,
        onUpdateBeatText,
        onUpdateGeneratedText,
        onDeleteBeat,
        onMoveBeat,
        onShowPrompt,
        onEditBeat,
      }) {
        return (
          <div className="scene-beat">
            <p
              style={{ marginBottom: "2px", fontSize: "0.9em", color: "#555" }}
            >
              <strong>Scene Beat Instruction:</strong>
            </p>
            <textarea
              className="beat-text-area"
              placeholder="Scene beat description / instruction..."
              value={beat.text || ""}
              onChange={(e) =>
                onUpdateBeatText(novelId, chapterId, beat.id, e.target.value)
              }
            />

            <div className="beat-controls">
              <button
                className="move-btn"
                onClick={() => onMoveBeat(novelId, chapterId, beat.id, -1)}
                disabled={beatIndex === 0}
              >
                ↑
              </button>
              <button
                className="move-btn"
                onClick={() => onMoveBeat(novelId, chapterId, beat.id, 1)}
                disabled={beatIndex === totalBeats - 1}
              >
                ↓
              </button>
              <button onClick={() => onEditBeat(novelId, chapterId, beat.id)}>
                Edit
              </button>
              <button onClick={() => onShowPrompt(novelId, chapterId, beat.id)}>
                Show Prompt
              </button>
              <button
                className="delete-btn"
                onClick={() => onDeleteBeat(novelId, chapterId, beat.id)}
              >
                Delete Beat
              </button>
            </div>

            <p
              style={{
                marginTop: "10px",
                marginBottom: "2px",
                fontSize: "0.9em",
                color: "#555",
              }}
            >
              <strong>AI Generated Content:</strong>
            </p>
            <textarea
              className="generated-text-area"
              placeholder="Paste AI generated content here..."
              value={beat.generatedText || ""}
              onChange={(e) =>
                onUpdateGeneratedText(
                  novelId,
                  chapterId,
                  beat.id,
                  e.target.value
                )
              }
            />
          </div>
        );
      }

      // --- ChapterSummary Component ---
      function ChapterSummary({
        novelId,
        chapter,
        isCollapsed,
        onToggleCollapse,
        onUpdateSummary,
        onCopySummaryPrompt,
      }) {
        const [copyFeedback, setCopyFeedback] = useState(false);

        const handleCopyPrompt = () => {
          onCopySummaryPrompt(novelId, chapter.id)
            .then(() => {
              setCopyFeedback(true);
              setTimeout(() => setCopyFeedback(false), 1500);
            })
            .catch((err) => {
              console.error("Failed to copy summary prompt:", err);
              alert("Failed to copy. See console for details.");
            });
        };

        return (
          <div>
            <div
              className={`summary-header ${isCollapsed ? "collapsed" : ""}`}
              onClick={() => onToggleCollapse(chapter.id)}
            >
              <span className="collapse-indicator">▼</span>
              <h4>Chapter Summary</h4>
            </div>
            <div
              className={`summary-section ${isCollapsed ? "collapsed" : ""}`}
            >
              <button onClick={handleCopyPrompt}>Copy Summary Prompt</button>
              <div className="feedback-container">
                <FeedbackMessage show={copyFeedback} />
              </div>
              <textarea
                className="summary-text-area"
                placeholder="Paste chapter summary generated by AI here..."
                value={chapter.summary || ""}
                onChange={(e) =>
                  onUpdateSummary(novelId, chapter.id, e.target.value)
                }
              />
            </div>
          </div>
        );
      }

      // --- Chapter Component ---
      function Chapter({
        novelId,
        chapter,
        chapterIndex,
        totalChapters,
        onUpdateChapterTitle,
        onDeleteChapter,
        onMoveChapter,
        onAddBeat,
        onUpdateBeatText,
        onUpdateGeneratedText,
        onDeleteBeat,
        onMoveBeat,
        onShowPrompt,
        isSummaryCollapsed,
        onToggleSummaryCollapse,
        onUpdateChapterSummary,
        onCopySummaryPrompt,
        onEditBeat,
      }) {
        const [newBeatText, setNewBeatText] = useState("");

        const handleAddBeat = () => {
          if (!newBeatText.trim()) {
            alert("Please enter some text for the scene beat instruction.");
            return;
          }
          onAddBeat(novelId, chapter.id, newBeatText);
          setNewBeatText(""); // Clear input after adding
        };

        return (
          <div className="chapter">
            <div className="chapter-header">
              <input
                type="text"
                className="chapter-title"
                value={chapter.title || ""}
                onChange={(e) =>
                  onUpdateChapterTitle(novelId, chapter.id, e.target.value)
                }
                placeholder="Chapter Title"
              />
              <div className="chapter-controls">
                <button
                  className="move-btn"
                  onClick={() => onMoveChapter(novelId, chapter.id, -1)}
                  disabled={chapterIndex === 0}
                >
                  ↑
                </button>
                <button
                  className="move-btn"
                  onClick={() => onMoveChapter(novelId, chapter.id, 1)}
                  disabled={chapterIndex === totalChapters - 1}
                >
                  ↓
                </button>
                <button
                  className="delete-btn"
                  onClick={() => onDeleteChapter(novelId, chapter.id)}
                >
                  Delete Chapter
                </button>
              </div>
            </div>

            <div className="scene-beats-container">
              {chapter.sceneBeats.length === 0 ? (
                <p style={{ color: "#888", fontStyle: "italic" }}>
                  No scene beats yet.
                </p>
              ) : (
                chapter.sceneBeats.map((beat, index) => (
                  <SceneBeat
                    key={beat.id}
                    novelId={novelId}
                    chapterId={chapter.id}
                    beat={beat}
                    beatIndex={index}
                    totalBeats={chapter.sceneBeats.length}
                    onUpdateBeatText={onUpdateBeatText}
                    onUpdateGeneratedText={onUpdateGeneratedText}
                    onDeleteBeat={onDeleteBeat}
                    onMoveBeat={onMoveBeat}
                    onShowPrompt={onShowPrompt}
                    onEditBeat={onEditBeat}
                  />
                ))
              )}
            </div>

            <div className="add-beat-area">
              <textarea
                className="new-beat-text"
                placeholder="Add new scene beat instruction..."
                value={newBeatText}
                onChange={(e) => setNewBeatText(e.target.value)}
              />
              <button onClick={handleAddBeat}>+ Add Beat</button>
            </div>

            <hr style={{ margin: "15px 0" }} />

            <ChapterSummary
              novelId={novelId}
              chapter={chapter}
              isCollapsed={isSummaryCollapsed}
              onToggleCollapse={onToggleSummaryCollapse}
              onUpdateSummary={onUpdateChapterSummary}
              onCopySummaryPrompt={onCopySummaryPrompt}
            />
          </div>
        );
      }

      // --- NovelEditorView Component ---
      function NovelEditorView({
        novel,
        onBack,
        onUpdateNovel,
        onDeleteNovel,
        // Chapter Actions
        onAddChapter,
        onDeleteChapter,
        onMoveChapter,
        onUpdateChapterTitle,
        // Beat Actions
        onAddBeat,
        onDeleteBeat,
        onMoveBeat,
        onUpdateBeatText,
        onUpdateGeneratedText,
        // Summary Actions
        onUpdateChapterSummary,
        // Other
        onExportNovel,
        onShowPrompt,
        onShowTemplateEditor,
        summaryCollapseStates,
        onToggleSummaryCollapse,
        onCopySummaryPrompt,
        onEditBeat,
      }) {
        const [exportFeedback, setExportFeedback] = useState(false);
        const [chapterFilter, setChapterFilter] = useState("all");

        const handleExport = () => {
          onExportNovel(novel.id)
            .then(() => {
              setExportFeedback(true);
              setTimeout(() => setExportFeedback(false), 1500);
            })
            .catch((err) => {
              console.error("Export failed:", err);
              alert("Export failed. See console for details.");
            });
        };

        const filteredChapters = useMemo(() => {
          if (chapterFilter === "all") {
            return novel.chapters;
          }
          return novel.chapters.filter((ch) => ch.id === chapterFilter);
        }, [novel.chapters, chapterFilter]);

        return (
          <div className="view" id="novelEditorView">
            <button onClick={onBack}>← Back to Novel List</button>
            <div className="novel-title-edit">
              <input
                type="text"
                id="editNovelTitle"
                value={novel.title || ""}
                onChange={(e) =>
                  onUpdateNovel(novel.id, { title: e.target.value })
                }
              />
            </div>
            <div className="import-export-area">
              <button onClick={handleExport}>Export Novel</button>
              <button onClick={() => onShowTemplateEditor(novel.id)}>
                Edit Continue Prompt Template
              </button>
              <div className="feedback-container">
                <FeedbackMessage show={exportFeedback} />
              </div>
            </div>
            <div className="chapter-filter">
              <label htmlFor="chapterFilter">Show chapter: </label>
              <select
                id="chapterFilter"
                value={chapterFilter}
                onChange={(e) => setChapterFilter(e.target.value)}
              >
                <option value="all">All Chapters</option>
                {novel.chapters.map((ch, index) => (
                  <option key={ch.id} value={ch.id}>
                    {ch.title || `Chapter ${index + 1}`}
                  </option>
                ))}
              </select>
            </div>
            <button
              className="delete-btn"
              onClick={() => onDeleteNovel(novel.id)}
            >
              Delete This Novel
            </button>
            <hr />

            <div id="chaptersContainer">
              {filteredChapters.length === 0 &&
                chapterFilter !== "all" &&
                novel.chapters.length > 0 && (
                  <p style={{ fontStyle: "italic", color: "#888" }}>
                    Chapter not found. Showing all chapters. Select "All
                    Chapters" above.
                  </p>
                )}
              {filteredChapters.length > 0
                ? filteredChapters.map((chapter) => {
                    // Find the original index for move button disabling
                    const originalIndex = novel.chapters.findIndex(
                      (ch) => ch.id === chapter.id
                    );
                    return (
                      <Chapter
                        key={chapter.id}
                        novelId={novel.id}
                        chapter={chapter}
                        chapterIndex={originalIndex} // Use original index for move logic
                        totalChapters={novel.chapters.length}
                        onUpdateChapterTitle={onUpdateChapterTitle}
                        onDeleteChapter={onDeleteChapter}
                        onMoveChapter={onMoveChapter}
                        onAddBeat={onAddBeat}
                        onUpdateBeatText={onUpdateBeatText}
                        onUpdateGeneratedText={onUpdateGeneratedText}
                        onDeleteBeat={onDeleteBeat}
                        onMoveBeat={onMoveBeat}
                        onShowPrompt={onShowPrompt}
                        isSummaryCollapsed={
                          typeof summaryCollapseStates[chapter.id] !==
                            "undefined" &&
                          summaryCollapseStates[chapter.id] !== null
                            ? summaryCollapseStates[chapter.id]
                            : true // Default collapsed
                        }
                        onToggleSummaryCollapse={onToggleSummaryCollapse}
                        onUpdateChapterSummary={onUpdateChapterSummary}
                        onCopySummaryPrompt={onCopySummaryPrompt}
                        onEditBeat={onEditBeat}
                      />
                    );
                  })
                : chapterFilter === "all" && (
                    <p>No chapters yet. Click "+ Add New Chapter" below.</p>
                  )}
            </div>

            <button onClick={() => onAddChapter(novel.id)}>
              + Add New Chapter
            </button>
          </div>
        );
      }

      // --- NovelListView Component ---
      function NovelListView({
        novels,
        onCreateNovel,
        onOpenNovel,
        onDeleteNovel,
        onImportNovel,
      }) {
        const [newNovelTitle, setNewNovelTitle] = useState("");
        const [importVisible, setImportVisible] = useState(false);
        const [importText, setImportText] = useState("");

        const handleCreate = () => {
          onCreateNovel(newNovelTitle);
          setNewNovelTitle(""); // Clear input
        };

        const handleImport = () => {
          if (!importText.trim()) {
            alert("Please paste the exported novel markdown content first.");
            return;
          }
          onImportNovel(importText);
          setImportText("");
          setImportVisible(false);
        };

        const toggleImport = () => {
          setImportVisible(!importVisible);
          if (importVisible) {
            // If closing
            setImportText("");
          }
        };

        const sortedNovels = useMemo(() => {
          // Ensure novels is always an array before sorting
          const novelsArray = Array.isArray(novels) ? novels : [];
          return [...novelsArray].sort((a, b) =>
            (a.title || "").localeCompare(b.title || "")
          );
        }, [novels]);

        return (
          <div className="view" id="novelListView">
            <h2>Novels</h2>
            <ul id="novelList">
              {sortedNovels.length === 0 ? (
                <li>No novels found. Create one below or import one.</li>
              ) : (
                sortedNovels.map((novel) => (
                  <li key={novel.id}>
                    <span
                      className="novel-item-title"
                      onClick={() => onOpenNovel(novel.id)}
                    >
                      {novel.title || "Untitled Novel"}
                    </span>
                    <div>
                      <button onClick={() => onOpenNovel(novel.id)}>
                        Open
                      </button>
                      <button
                        className="delete-btn"
                        onClick={() => onDeleteNovel(novel.id)}
                      >
                        Delete
                      </button>
                    </div>
                  </li>
                ))
              )}
            </ul>
            <div>
              <input
                type="text"
                id="newNovelTitle"
                placeholder="New Novel Title"
                value={newNovelTitle}
                onChange={(e) => setNewNovelTitle(e.target.value)}
              />
              <button onClick={handleCreate}>Create New Novel</button>
              <button onClick={toggleImport}>
                {importVisible ? "Cancel Import" : "Import Novel"}
              </button>
            </div>

            {importVisible && (
              <div className="import-area show">
                <textarea
                  id="importText"
                  placeholder="Paste exported novel markdown here..."
                  value={importText}
                  onChange={(e) => setImportText(e.target.value)}
                ></textarea>
                <button onClick={handleImport}>Import</button>
                <button className="secondary-btn" onClick={toggleImport}>
                  Cancel
                </button>
              </div>
            )}
          </div>
        );
      }

      // --- Main App Component ---
      function App() {
        const [novels, setNovels] = useState([]);
        const [currentView, setCurrentView] = useState("list"); // 'list' or 'editor'
        const [currentNovelId, setCurrentNovelId] = useState(null);
        const [modalContent, setModalContent] = useState(null); // { type: 'prompt'/'template', data: ... }
        const [summaryCollapseStates, setSummaryCollapseStates] = useState({});

        // --- Load initial data ---
        useEffect(() => {
          // Load Novels
          const storedNovels = localStorage.getItem(LS_KEY);
          let loadedNovels = [];
          if (storedNovels) {
            try {
              loadedNovels = JSON.parse(storedNovels);
              // Ensure loadedNovels is an array
              if (!Array.isArray(loadedNovels)) {
                console.warn("Loaded novels data is not an array, resetting.");
                loadedNovels = [];
              }
              // Basic validation/migration
              loadedNovels.forEach((novel) => {
                // Check if novel is an object
                if (typeof novel !== "object" || novel === null) return;

                novel.template =
                  novel.template === undefined ? null : novel.template; // Add template field if missing
                novel.chapters = Array.isArray(novel.chapters)
                  ? novel.chapters
                  : [];
                novel.chapters.forEach((chapter) => {
                  if (typeof chapter !== "object" || chapter === null) return;
                  chapter.sceneBeats = Array.isArray(chapter.sceneBeats)
                    ? chapter.sceneBeats
                    : [];
                  chapter.summary = chapter.summary || "";
                  chapter.sceneBeats.forEach((beat) => {
                    if (typeof beat !== "object" || beat === null) return;
                    beat.generatedText = beat.generatedText || "";
                    beat.text = beat.text || ""; // Ensure text field exists
                  });
                });
              });
            } catch (e) {
              console.error("Error parsing novels from local storage:", e);
              loadedNovels = [];
            }
          }
          setNovels(loadedNovels);

          // Load Summary Collapse States
          const storedStates = localStorage.getItem(LS_SUMMARY_STATE_KEY);
          try {
            const loadedStates = JSON.parse(storedStates || "{}");
            setSummaryCollapseStates(
              typeof loadedStates === "object" && loadedStates !== null
                ? loadedStates
                : {}
            );
          } catch (e) {
            console.error("Error parsing summary states:", e);
            setSummaryCollapseStates({});
          }
        }, []); // Empty dependency array means run only once on mount

        // --- Save data to local storage on change ---
        useEffect(() => {
          // Only save if novels is actually an array
          if (Array.isArray(novels)) {
            try {
              localStorage.setItem(LS_KEY, JSON.stringify(novels));
            } catch (e) {
              console.error("Error saving novels:", e);
              alert("Error saving novel data. Local storage might be full.");
            }
          }
        }, [novels]); // Run whenever novels state changes

        useEffect(() => {
          try {
            localStorage.setItem(
              LS_SUMMARY_STATE_KEY,
              JSON.stringify(summaryCollapseStates)
            );
          } catch (e) {
            console.error("Error saving summary states:", e);
            // Don't alert for this, less critical
          }
        }, [summaryCollapseStates]); // Run whenever collapse states change

        // --- State Update Helper (Immutability!) ---
        const updateNovels = (updateFn) => {
          setNovels((prevNovels) => {
            // Ensure prevNovels is an array before applying the update function
            const currentNovels = Array.isArray(prevNovels) ? prevNovels : [];
            return updateFn(currentNovels);
          });
        };

        // --- Novel Actions ---
        const handleCreateNovel = (title) => {
          const newNovel = {
            id: generateId(),
            title: title.trim() || "Untitled Novel",
            template: null,
            chapters: [],
          };
          updateNovels((prev) => [...prev, newNovel]);
          setCurrentNovelId(newNovel.id); // Open the new novel
          setCurrentView("editor");
        };

        const handleOpenNovel = (id) => {
          setCurrentNovelId(id);
          setCurrentView("editor");
        };

        const handleDeleteNovel = (id) => {
          const novelToDelete = novels.find((n) => n.id === id);
          if (!novelToDelete) return;
          if (
            confirm(
              `Are you sure you want to delete the novel "${
                novelToDelete.title || "Untitled Novel"
              }"? This action cannot be undone.`
            )
          ) {
            updateNovels((prev) => prev.filter((novel) => novel.id !== id));
            if (currentNovelId === id) {
              setCurrentView("list");
              setCurrentNovelId(null);
            }
            // Clean up summary states for deleted novel's chapters (optional but good practice)
            setSummaryCollapseStates((prevStates) => {
              const newStates = { ...prevStates };
              // Check if chapters exist before iterating
              if (Array.isArray(novelToDelete.chapters)) {
                novelToDelete.chapters.forEach((ch) => delete newStates[ch.id]);
              }
              return newStates;
            });
          }
        };

        const handleUpdateNovel = (id, updates) => {
          updateNovels((prev) =>
            prev.map((novel) =>
              novel.id === id ? { ...novel, ...updates } : novel
            )
          );
        };

        const handleBackToList = () => {
          setCurrentView("list");
          setCurrentNovelId(null);
        };

        // --- Chapter Actions ---
        const handleAddChapter = (novelId) => {
          const newChapter = {
            id: generateId(),
            title: "", // Start untitled
            sceneBeats: [],
            summary: "",
          };
          updateNovels((prev) =>
            prev.map((novel) => {
              if (novel.id === novelId) {
                // Ensure chapters is an array before accessing length
                const currentChapters = Array.isArray(novel.chapters)
                  ? novel.chapters
                  : [];
                // Assign default title based on new position
                newChapter.title = `Chapter ${currentChapters.length + 1}`;
                return { ...novel, chapters: [...currentChapters, newChapter] };
              }
              return novel;
            })
          );
          // Optionally scroll to new chapter - requires DOM refs, more complex in React
        };

        const handleDeleteChapter = (novelId, chapterId) => {
          const novel = novels.find((n) => n.id === novelId);
          // ****** FIXED HERE ******
          // Replace novel?.chapters with novel && novel.chapters
          const chapter =
            novel &&
            Array.isArray(novel.chapters) &&
            novel.chapters.find((c) => c.id === chapterId);
          // ****** END FIX ******
          if (!novel || !chapter) return;

          if (
            confirm(
              `Are you sure you want to delete "${
                chapter.title || "this chapter"
              }" and all its scene beats?`
            )
          ) {
            updateNovels((prev) =>
              prev.map((n) => {
                if (n.id === novelId) {
                  // Ensure chapters is an array before filtering
                  const currentChapters = Array.isArray(n.chapters)
                    ? n.chapters
                    : [];
                  return {
                    ...n,
                    chapters: currentChapters.filter(
                      (ch) => ch.id !== chapterId
                    ),
                  };
                }
                return n;
              })
            );
            // Clean up summary state
            setSummaryCollapseStates((prevStates) => {
              const newStates = { ...prevStates };
              delete newStates[chapterId];
              return newStates;
            });
          }
        };

        const handleUpdateChapterTitle = (novelId, chapterId, newTitle) => {
          updateNovels((prev) =>
            prev.map((n) => {
              if (n.id === novelId) {
                const currentChapters = Array.isArray(n.chapters)
                  ? n.chapters
                  : [];
                return {
                  ...n,
                  chapters: currentChapters.map((ch) =>
                    ch.id === chapterId
                      ? { ...ch, title: newTitle.trim() || "Untitled Chapter" }
                      : ch
                  ),
                };
              }
              return n;
            })
          );
        };

        const handleMoveChapter = (novelId, chapterId, direction) => {
          updateNovels((prev) =>
            prev.map((n) => {
              if (n.id === novelId) {
                const currentChapters = Array.isArray(n.chapters)
                  ? n.chapters
                  : [];
                const chapters = [...currentChapters]; // Create mutable copy
                const index = chapters.findIndex((ch) => ch.id === chapterId);
                if (index === -1) return n; // Should not happen

                const newIndex = index + direction;
                if (newIndex < 0 || newIndex >= chapters.length) return n; // Invalid move

                // Swap
                [chapters[index], chapters[newIndex]] = [
                  chapters[newIndex],
                  chapters[index],
                ];

                return { ...n, chapters: chapters };
              }
              return n;
            })
          );
        };

        // --- Scene Beat Actions ---
        const handleAddBeat = (novelId, chapterId, text) => {
          const newBeat = {
            id: generateId(),
            text: text.trim(),
            generatedText: "",
          };
          updateNovels((prev) =>
            prev.map((n) => {
              if (n.id === novelId) {
                const currentChapters = Array.isArray(n.chapters)
                  ? n.chapters
                  : [];
                return {
                  ...n,
                  chapters: currentChapters.map((ch) => {
                    if (ch.id === chapterId) {
                      const currentBeats = Array.isArray(ch.sceneBeats)
                        ? ch.sceneBeats
                        : [];
                      return { ...ch, sceneBeats: [...currentBeats, newBeat] };
                    }
                    return ch;
                  }),
                };
              }
              return n;
            })
          );
        };

        // New Edit Beat function
        const handleEditBeat = (novelId, chapterId, beatId) => {
          const novel = novels.find(n => n.id === novelId);
          if (!novel || !Array.isArray(novel.chapters)) return;
          
          const chapter = novel.chapters.find(ch => ch.id === chapterId);
          if (!chapter || !Array.isArray(chapter.sceneBeats)) return;
          
          const beat = chapter.sceneBeats.find(b => b.id === beatId);
          if (!beat) return;
          
          setModalContent({
            type: "editBeat",
            data: {
              novelId,
              chapterId,
              beatId,
              text: beat.text || ""
            }
          });
        };
        
        const handleSaveBeatEdit = (novelId, chapterId, beatId, newText) => {
          handleUpdateBeatText(novelId, chapterId, beatId, newText);
          handleCloseModal();
        };

        const handleDeleteBeat = (novelId, chapterId, beatId) => {
          if (confirm("Are you sure you want to delete this scene beat?")) {
            updateNovels((prev) =>
              prev.map((n) => {
                if (n.id === novelId) {
                  const currentChapters = Array.isArray(n.chapters)
                    ? n.chapters
                    : [];
                  return {
                    ...n,
                    chapters: currentChapters.map((ch) => {
                      if (ch.id === chapterId) {
                        const currentBeats = Array.isArray(ch.sceneBeats)
                          ? ch.sceneBeats
                          : [];
                        return {
                          ...ch,
                          sceneBeats: currentBeats.filter(
                            (b) => b.id !== beatId
                          ),
                        };
                      }
                      return ch;
                    }),
                  };
                }
                return n;
              })
            );
          }
        };

        const handleUpdateBeatText = (novelId, chapterId, beatId, newText) => {
          updateNovels((prev) =>
            prev.map((n) => {
              if (n.id === novelId) {
                const currentChapters = Array.isArray(n.chapters)
                  ? n.chapters
                  : [];
                return {
                  ...n,
                  chapters: currentChapters.map((ch) => {
                    if (ch.id === chapterId) {
                      const currentBeats = Array.isArray(ch.sceneBeats)
                        ? ch.sceneBeats
                        : [];
                      return {
                        ...ch,
                        sceneBeats: currentBeats.map((b) =>
                          b.id === beatId ? { ...b, text: newText } : b
                        ),
                      };
                    }
                    return ch;
                  }),
                };
              }
              return n;
            })
          );
        };

        const handleUpdateGeneratedText = (
          novelId,
          chapterId,
          beatId,
          genText
        ) => {
          updateNovels((prev) =>
            prev.map((n) => {
              if (n.id === novelId) {
                const currentChapters = Array.isArray(n.chapters)
                  ? n.chapters
                  : [];
                return {
                  ...n,
                  chapters: currentChapters.map((ch) => {
                    if (ch.id === chapterId) {
                      const currentBeats = Array.isArray(ch.sceneBeats)
                        ? ch.sceneBeats
                        : [];
                      return {
                        ...ch,
                        sceneBeats: currentBeats.map((b) =>
                          b.id === beatId ? { ...b, generatedText: genText } : b
                        ),
                      };
                    }
                    return ch;
                  }),
                };
              }
              return n;
            })
          );
        };

        const handleMoveBeat = (novelId, chapterId, beatId, direction) => {
          updateNovels((prev) =>
            prev.map((n) => {
              if (n.id === novelId) {
                const currentChapters = Array.isArray(n.chapters)
                  ? n.chapters
                  : [];
                return {
                  ...n,
                  chapters: currentChapters.map((ch) => {
                    if (ch.id === chapterId) {
                      const currentBeats = Array.isArray(ch.sceneBeats)
                        ? ch.sceneBeats
                        : [];
                      const beats = [...currentBeats]; // Mutable copy
                      const index = beats.findIndex((b) => b.id === beatId);
                      if (index === -1) return ch;

                      const newIndex = index + direction;
                      if (newIndex < 0 || newIndex >= beats.length) return ch;

                      // Swap
                      [beats[index], beats[newIndex]] = [
                        beats[newIndex],
                        beats[index],
                      ];

                      return { ...ch, sceneBeats: beats };
                    }
                    return ch;
                  }),
                };
              }
              return n;
            })
          );
        };

        // --- Summary Actions ---
        const handleUpdateChapterSummary = (
          novelId,
          chapterId,
          summaryText
        ) => {
          updateNovels((prev) =>
            prev.map((n) => {
              if (n.id === novelId) {
                const currentChapters = Array.isArray(n.chapters)
                  ? n.chapters
                  : [];
                return {
                  ...n,
                  chapters: currentChapters.map((ch) =>
                    ch.id === chapterId ? { ...ch, summary: summaryText } : ch
                  ),
                };
              }
              return n;
            })
          );
        };

        // ****** FIXED HERE ******
        const handleToggleSummaryCollapse = (chapterId) => {
          setSummaryCollapseStates((prevStates) => {
            // Replace prevStates[chapterId] ?? true with compatible check
            const currentState =
              typeof prevStates[chapterId] !== "undefined" &&
              prevStates[chapterId] !== null
                ? prevStates[chapterId]
                : true; // Default to collapsed (true) if undefined/null
            return {
              ...prevStates,
              [chapterId]: !currentState, // Toggle the determined state
            };
          });
        };
        // ****** END FIX ******

        // --- Prompt Generation ---
        const generatePromptText = (novelId, chapterId, beatId) => {
          const novel = novels.find((n) => n.id === novelId);
          if (!novel || !Array.isArray(novel.chapters))
            return { error: "Novel or chapters not found/invalid" };

          const chapterIndex = novel.chapters.findIndex(
            (ch) => ch.id === chapterId
          );
          const chapter = novel.chapters[chapterIndex];
          if (!chapter || !Array.isArray(chapter.sceneBeats))
            return { error: "Chapter or scene beats not found/invalid" };

          const beatIndex = chapter.sceneBeats.findIndex(
            (b) => b.id === beatId
          );
          const beat = chapter.sceneBeats[beatIndex];
          if (beatIndex === -1 || !beat)
            return { error: "Scene beat not found" };

          // Build story so far
          let storySoFar = "";
          const maxContextLength = 10000;

          // Previous chapters context
          for (let i = 0; i < chapterIndex; i++) {
            const prevChapter = novel.chapters[i];
            // Ensure prevChapter and its beats are valid before processing
            if (!prevChapter || !Array.isArray(prevChapter.sceneBeats))
              continue;

            let chapterContext = "";
            if (prevChapter.summary) {
              chapterContext = `Summary of Chapter ${i + 1}: ${
                prevChapter.title || "Untitled"
              }\n${prevChapter.summary}\n\n`;
            } else {
              const prevChapterText = prevChapter.sceneBeats
                .map((b) => b.generatedText || "")
                .filter(Boolean)
                .join("\n\n");
              if (prevChapterText) {
                chapterContext = `Content from Chapter ${i + 1}: ${
                  prevChapter.title || "Untitled"
                }\n${prevChapterText}\n\n`;
              }
            }
            if (
              storySoFar.length + chapterContext.length <
              maxContextLength * 1.2
            ) {
              storySoFar += chapterContext;
            } else {
              break;
            }
          }

          // Previous beats in current chapter
          for (let i = 0; i < beatIndex; i++) {
            const prevBeat = chapter.sceneBeats[i];
            if (prevBeat && prevBeat.generatedText) {
              // Check prevBeat exists
              const beatText = prevBeat.generatedText + "\n\n";
              if (
                storySoFar.length + beatText.length <
                maxContextLength * 1.2
              ) {
                storySoFar += beatText;
              } else {
                break;
              }
            }
          }

          // Truncate if needed
          if (storySoFar.length > maxContextLength) {
            const excess = storySoFar.length - maxContextLength;
            storySoFar =
              `... (trimmed ${excess} characters)\n` + storySoFar.slice(excess);
          }

          storySoFar = storySoFar.trim();

          const template = getEffectiveTemplate(novel);
          const instructionsText = beat.text || "";

          let prompt = template.replace(
            "{storySoFar}",
            storySoFar || "This is the beginning of the story."
          );
          prompt = prompt.replace("{instructions}", instructionsText);

          return { prompt: prompt.trim() };
        };

        // --- Modal Handling ---
        const handleShowPrompt = (novelId, chapterId, beatId) => {
          const { prompt, error } = generatePromptText(
            novelId,
            chapterId,
            beatId
          );
          if (error) {
            alert(`Error generating prompt: ${error}`);
            return;
          }
          setModalContent({ type: "prompt", data: { text: prompt } });
        };

        const handleShowTemplateEditor = (novelId) => {
          const novel = novels.find((n) => n.id === novelId);
          if (!novel) return;
          setModalContent({
            type: "template",
            data: {
              novelId: novel.id,
              currentTemplate: getEffectiveTemplate(novel),
            },
          });
        };

        const handleShowExportModal = (exportText) => {
          setModalContent({
            type: "export",
            data: { text: exportText }
          });
        };

        const handleCloseModal = () => {
          setModalContent(null);
        };

        const handleSaveTemplate = (novelId, newTemplate) => {
          const templateToSave =
            newTemplate.trim() !== DEFAULT_PROMPT_TEMPLATE.trim()
              ? newTemplate
              : null;
          handleUpdateNovel(novelId, { template: templateToSave });
          // Optionally close modal or show feedback inside
          // For simplicity, we'll just close it here
          handleCloseModal();
        };

        // --- Copy Actions ---
        const handleCopyPromptFromModal = (text) => {
          return copyToClipboard(text); // Returns a promise
        };

        const handleCopySummaryPrompt = (novelId, chapterId) => {
          const novel = novels.find((n) => n.id === novelId);
          // ****** FIXED HERE ******
          // Replace novel?.chapters with novel && novel.chapters
          const chapter =
            novel &&
            Array.isArray(novel.chapters) &&
            novel.chapters.find((c) => c.id === chapterId);
          // ****** END FIX ******
          if (!chapter || !Array.isArray(chapter.sceneBeats))
            return Promise.reject(
              new Error("Chapter or scene beats not found/invalid")
            );

          const chapterText = chapter.sceneBeats
            .map((beat) => beat.generatedText || "")
            .filter(Boolean)
            .join("\n\n");

          if (!chapterText) {
            alert("No generated content in this chapter to summarize.");
            return Promise.reject(new Error("No content to summarize"));
          }

          const prompt = `Please write a concise summary of the following chapter content:\n\n${chapterText}`;
          return copyToClipboard(prompt);
        };

        // --- Import / Export ---
        const handleExportNovel = (novelId) => {
          return new Promise((resolve, reject) => {
            const novel = novels.find((n) => n.id === novelId);
            if (!novel) return reject(new Error("Novel not found"));

            let markdown = `# ${novel.title || "Untitled Novel"}\n\n`; // Add default title
            markdown += `### Template\n\n`;
            markdown += `${getEffectiveTemplate(novel)}\n\n`;

            // Ensure chapters is an array before iterating
            const currentChapters = Array.isArray(novel.chapters)
              ? novel.chapters
              : [];
            currentChapters.forEach((chapter, chapterIndex) => {
              markdown += `## ${
                chapter.title || `Chapter ${chapterIndex + 1}`
              }\n\n`; // Add default title
              if (chapter.summary) {
                markdown += `### Summary\n\n${chapter.summary}\n\n`;
              }
              markdown += `### Scene Beats\n\n`;

              // Ensure sceneBeats is an array before iterating
              const currentBeats = Array.isArray(chapter.sceneBeats)
                ? chapter.sceneBeats
                : [];
              currentBeats.forEach((beat, beatIndex) => {
                markdown += `#### Beat ${beatIndex + 1}\n\n`;
                markdown += `**Scene Description:**\n${beat.text || ""}\n\n`;
                markdown += `**Generated Content:**\n${
                  beat.generatedText || ""
                }\n\n`;
              });
            });

            // Show in modal instead of directly copying
            handleShowExportModal(markdown.trim());
            resolve();
          });
        };

        const handleImportNovel = (text) => {
          try {
            const novel = {
              id: generateId(),
              title: "Imported Novel",
              template: null,
              chapters: [],
            };

            const lines = text.split("\n");
            let currentChapter = null;
            let currentBeat = null;
            let readingMode = null; // null | 'summary' | 'description' | 'generated' | 'template'
            let accumulatingText = "";

            lines.forEach((line) => {
              const trimmedLine = line.trim();

              if (trimmedLine.startsWith("# ")) {
                finishAccumulatingText();
                novel.title = trimmedLine.substring(2).trim();
                readingMode = null;
              } else if (trimmedLine.startsWith("## ")) {
                finishAccumulatingText();
                currentChapter = {
                  id: generateId(),
                  title: trimmedLine.substring(3).trim(),
                  summary: "",
                  sceneBeats: [],
                };
                novel.chapters.push(currentChapter);
                currentBeat = null;
                readingMode = null;
              } else if (trimmedLine === "### Template") {
                finishAccumulatingText();
                readingMode = "template";
              } else if (trimmedLine === "### Summary" && currentChapter) {
                finishAccumulatingText();
                readingMode = "summary";
              } else if (trimmedLine === "### Scene Beats" && currentChapter) {
                finishAccumulatingText();
                readingMode = null;
              } else if (
                trimmedLine.startsWith("#### Beat") &&
                currentChapter
              ) {
                finishAccumulatingText();
                currentBeat = { id: generateId(), text: "", generatedText: "" };
                currentChapter.sceneBeats.push(currentBeat);
                readingMode = null;
              } else if (
                trimmedLine === "**Scene Description:**" &&
                currentBeat
              ) {
                finishAccumulatingText();
                readingMode = "description";
              } else if (
                trimmedLine === "**Generated Content:**" &&
                currentBeat
              ) {
                finishAccumulatingText();
                readingMode = "generated";
              } else {
                accumulatingText += line + "\n";
              }
            });

            finishAccumulatingText(); // Finish last section

            function finishAccumulatingText() {
              const content = accumulatingText.trim();
              if (readingMode === "template") {
                novel.template =
                  content && content !== DEFAULT_PROMPT_TEMPLATE
                    ? content
                    : null;
              } else if (readingMode === "summary" && currentChapter) {
                currentChapter.summary = content;
              } else if (readingMode === "description" && currentBeat) {
                currentBeat.text = content;
              } else if (readingMode === "generated" && currentBeat) {
                currentBeat.generatedText = content;
              }
              accumulatingText = "";
            }

            if (
              !novel.title ||
              ((!Array.isArray(novel.chapters) ||
                novel.chapters.length === 0) &&
                !novel.template)
            ) {
              console.warn("Imported text might be incomplete or invalid.");
            }

            // Ensure imported chapters/beats have arrays if empty
            if (Array.isArray(novel.chapters)) {
              novel.chapters.forEach((ch) => {
                ch.sceneBeats = Array.isArray(ch.sceneBeats)
                  ? ch.sceneBeats
                  : [];
              });
            } else {
              novel.chapters = [];
            }

            updateNovels((prev) => [...prev, novel]);
          } catch (e) {
            console.error("Import error:", e);
            alert(
              "Error importing novel. Please check the format.\n\n" + e.message
            );
          }
        };

        // --- Current Novel Data (Memoized) ---
        const currentNovel = useMemo(() => {
          // Ensure novels is an array before finding
          if (!Array.isArray(novels)) return null;
          return novels.find((n) => n.id === currentNovelId) || null;
        }, [novels, currentNovelId]);

        // --- Render Logic ---
        return (
          <div className="container">
            <h1>NovelTokenToken</h1>

            {currentView === "list" && (
              <NovelListView
                novels={novels}
                onCreateNovel={handleCreateNovel}
                onOpenNovel={handleOpenNovel}
                onDeleteNovel={handleDeleteNovel}
                onImportNovel={handleImportNovel}
              />
            )}

            {currentView === "editor" && currentNovel && (
              <NovelEditorView
                novel={currentNovel}
                onBack={handleBackToList}
                onUpdateNovel={handleUpdateNovel}
                onDeleteNovel={handleDeleteNovel}
                onAddChapter={handleAddChapter}
                onDeleteChapter={handleDeleteChapter}
                onMoveChapter={handleMoveChapter}
                onUpdateChapterTitle={handleUpdateChapterTitle}
                onAddBeat={handleAddBeat}
                onDeleteBeat={handleDeleteBeat}
                onMoveBeat={handleMoveBeat}
                onUpdateBeatText={handleUpdateBeatText}
                onUpdateGeneratedText={handleUpdateGeneratedText}
                onUpdateChapterSummary={handleUpdateChapterSummary}
                onExportNovel={handleExportNovel}
                onShowPrompt={handleShowPrompt}
                onShowTemplateEditor={handleShowTemplateEditor}
                summaryCollapseStates={summaryCollapseStates}
                onToggleSummaryCollapse={handleToggleSummaryCollapse}
                onCopySummaryPrompt={handleCopySummaryPrompt}
                onEditBeat={handleEditBeat}
              />
            )}

            {/* Render Modals */}
            {/* ****** FIXED HERE ****** */}
            {/* Replace modalContent?.type with modalContent && modalContent.type */}
            {modalContent && modalContent.type === "prompt" && (
              <PromptModal
                // Ensure data exists before accessing text
                promptText={modalContent.data && modalContent.data.text}
                onClose={handleCloseModal}
                onCopy={handleCopyPromptFromModal}
              />
            )}
            {/* Replace modalContent?.type with modalContent && modalContent.type */}
            {modalContent && modalContent.type === "template" && (
              <TemplateEditorModal
                // Ensure data exists before accessing properties
                novelId={modalContent.data && modalContent.data.novelId}
                currentTemplate={
                  modalContent.data && modalContent.data.currentTemplate
                }
                onClose={handleCloseModal}
                onSave={handleSaveTemplate}
                defaultTemplate={DEFAULT_PROMPT_TEMPLATE}
              />
            )}
            {/* ****** END FIX ****** */}
            {modalContent && modalContent.type === "export" && (
              <ExportModal
                exportText={modalContent.data && modalContent.data.text}
                onClose={handleCloseModal}
                onCopy={handleCopyPromptFromModal}
              />
            )}
            {modalContent && modalContent.type === "editBeat" && (
              <EditBeatModal
                beatText={modalContent.data && modalContent.data.text}
                onClose={handleCloseModal}
                onSave={(editedText) => handleSaveBeatEdit(
                  modalContent.data.novelId,
                  modalContent.data.chapterId,
                  modalContent.data.beatId,
                  editedText
                )}
              />
            )}
          </div>
        );
      }

      // --- Specific Modal Components ---
      function PromptModal({ promptText, onClose, onCopy }) {
        const [copyFeedback, setCopyFeedback] = useState(""); // "Copied", "Error"

        const handleCopy = () => {
          onCopy(promptText)
            .then(() => {
              setCopyFeedback("Copied!");
              setTimeout(() => setCopyFeedback(""), 1500);
            })
            .catch((err) => {
              console.error("Copy failed:", err);
              setCopyFeedback("Error");
              setTimeout(() => setCopyFeedback(""), 1500);
            });
        };

        return (
          <Modal
            title="Scene Beat Prompt"
            onClose={onClose}
            footer={
              <React.Fragment>
                <button onClick={handleCopy} disabled={!!copyFeedback}>
                  {copyFeedback || "Copy to Clipboard"}
                </button>
                <button className="secondary-btn" onClick={onClose}>
                  Close
                </button>
              </React.Fragment>
            }
          >
            <textarea
              className="prompt-textarea"
              value={promptText || ""} // Ensure value is not null/undefined
              readOnly
            />
          </Modal>
        );
      }

      function TemplateEditorModal({
        novelId,
        currentTemplate,
        onClose,
        onSave,
        defaultTemplate,
      }) {
        const [templateText, setTemplateText] = useState(currentTemplate || ""); // Ensure value is not null/undefined
        const [saveFeedback, setSaveFeedback] = useState("");

        useEffect(() => {
          setTemplateText(currentTemplate || ""); // Update if prop changes while open
        }, [currentTemplate]);

        const handleSave = () => {
          onSave(novelId, templateText);
          // Feedback handled by caller for simplicity now, could add internal feedback too
          // setSaveFeedback("Saved!");
          // setTimeout(() => setSaveFeedback(""), 1500);
        };

        const handleReset = () => {
          if (
            confirm(
              "Are you sure you want to reset the template in the editor to the default? This won't save until you click 'Save Template'."
            )
          ) {
            setTemplateText(defaultTemplate);
          }
        };

        return (
          <Modal
            title="Edit Continue Prompt Template"
            onClose={onClose}
            footer={
              <React.Fragment>
                <button onClick={handleSave} disabled={!!saveFeedback}>
                  {saveFeedback || "Save Template"}
                </button>
                <button className="secondary-btn" onClick={handleReset}>
                  Reset to Default
                </button>
                <button className="secondary-btn" onClick={onClose}>
                  Close
                </button>
              </React.Fragment>
            }
          >
            <textarea
              id="templateTextarea"
              className="prompt-textarea"
              value={templateText}
              onChange={(e) => setTemplateText(e.target.value)}
            />
            <div className="template-help">
              <p>Use these placeholders:</p>
              <ul>
                <li>
                  <code>{"{storySoFar}"}</code> - Context from previous
                  chapters/beats.
                </li>
                <li>
                  <code>{"{instructions}"}</code> - The text from the current
                  scene beat description.
                </li>
              </ul>
            </div>
          </Modal>
        );
      }

      function ExportModal({ exportText, onClose, onCopy }) {
        const [copyFeedback, setCopyFeedback] = useState(false);

        const handleCopy = () => {
          onCopy(exportText)
            .then(() => {
              setCopyFeedback(true);
              setTimeout(() => setCopyFeedback(false), 1500);
            })
            .catch((err) => {
              console.error("Copy failed:", err);
              alert("Failed to copy. See console for details.");
            });
        };

        return (
          <Modal
            title="Export Preview"
            onClose={onClose}
            footer={
              <React.Fragment>
                <button onClick={handleCopy} disabled={copyFeedback}>
                  {copyFeedback ? "Copied!" : "Copy to Clipboard"}
                </button>
                <button className="secondary-btn" onClick={onClose}>
                  Close
                </button>
              </React.Fragment>
            }
          >
            <textarea
              className="prompt-textarea"
              value={exportText || ""}
              readOnly
            />
          </Modal>
        );
      }

      // --- Edit Beat Modal Component ---
      function EditBeatModal({ beatText, onClose, onSave }) {
        const [editedText, setEditedText] = useState(beatText || "");
        
        const handleSave = () => {
          onSave(editedText);
        };

        return (
          <Modal
            title="Edit Scene Beat Instruction"
            onClose={onClose}
            footer={
              <React.Fragment>
                <button onClick={handleSave}>Save Changes</button>
                <button className="secondary-btn" onClick={onClose}>Cancel</button>
              </React.Fragment>
            }
          >
            <textarea
              className="prompt-textarea"
              value={editedText}
              onChange={(e) => setEditedText(e.target.value)}
              placeholder="Enter scene beat instruction..."
            />
          </Modal>
        );
      }

      // --- Render the App ---
      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
  </body>
</html>
